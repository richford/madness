<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>MADNESS: Linear algebra (interface to LAPACK)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MADNESS
   &#160;<span id="projectnumber">version 0.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Linear algebra (interface to LAPACK)<div class="ingroups"><a class="el" href="group__libraries.html">MADNESS libraries</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Linear algebra (interface to LAPACK):</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__linalg.png" border="0" alt="" usemap="#group____linalg"/>
<map name="group____linalg" id="group____linalg">
<area shape="rect" id="node1" href="group__libraries.html" title="MADNESS libraries" alt="" coords="5,13,145,41"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:tensor__lapack_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tensor__lapack_8h.html">tensor_lapack.h</a></td></tr>
<tr class="memdesc:tensor__lapack_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototypes for a partial interface from Tensor to LAPACK. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga90a353ae981da60c007a5eab9e8e1670"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga90a353ae981da60c007a5eab9e8e1670"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linalg.html#ga90a353ae981da60c007a5eab9e8e1670">madness::svd</a> (const Tensor&lt; T &gt; &amp;<a class="el" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>, Tensor&lt; T &gt; &amp;U, Tensor&lt; typename Tensor&lt; T &gt;::scalar_type &gt; &amp;s, Tensor&lt; T &gt; &amp;VT)</td></tr>
<tr class="memdesc:ga90a353ae981da60c007a5eab9e8e1670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the singluar value decomposition of an n-by-m matrix using *gesvd.  <a href="#ga90a353ae981da60c007a5eab9e8e1670">More...</a><br /></td></tr>
<tr class="separator:ga90a353ae981da60c007a5eab9e8e1670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga131173fdb385d4e6ceef5f38d5f27ccc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga131173fdb385d4e6ceef5f38d5f27ccc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linalg.html#ga131173fdb385d4e6ceef5f38d5f27ccc">madness::svd_result</a> (Tensor&lt; T &gt; &amp;<a class="el" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>, Tensor&lt; T &gt; &amp;U, Tensor&lt; typename Tensor&lt; T &gt;::scalar_type &gt; &amp;s, Tensor&lt; T &gt; &amp;VT, Tensor&lt; T &gt; &amp;work)</td></tr>
<tr class="memdesc:ga131173fdb385d4e6ceef5f38d5f27ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">same as svd, but it optimizes away the tensor construction: a = U * diag(s) * VT  <a href="#ga131173fdb385d4e6ceef5f38d5f27ccc">More...</a><br /></td></tr>
<tr class="separator:ga131173fdb385d4e6ceef5f38d5f27ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga865ca226164574b67f1f7ff6fe75eef5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga865ca226164574b67f1f7ff6fe75eef5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linalg.html#ga865ca226164574b67f1f7ff6fe75eef5">madness::gesv</a> (const Tensor&lt; T &gt; &amp;<a class="el" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>, const Tensor&lt; T &gt; &amp;<a class="el" href="y1_8cc.html#a8edb09333aecbc60d69c0ce58542e31d">b</a>, Tensor&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:ga865ca226164574b67f1f7ff6fe75eef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve Ax = b for general A using the LAPACK *gesv routines.  <a href="#ga865ca226164574b67f1f7ff6fe75eef5">More...</a><br /></td></tr>
<tr class="separator:ga865ca226164574b67f1f7ff6fe75eef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77bb5f0d7489b133019bf5f1a7a99368"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga77bb5f0d7489b133019bf5f1a7a99368"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linalg.html#ga77bb5f0d7489b133019bf5f1a7a99368">madness::gelss</a> (const Tensor&lt; T &gt; &amp;<a class="el" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>, const Tensor&lt; T &gt; &amp;<a class="el" href="y1_8cc.html#a8edb09333aecbc60d69c0ce58542e31d">b</a>, double rcond, Tensor&lt; T &gt; &amp;x, Tensor&lt; typename Tensor&lt; T &gt;::scalar_type &gt; &amp;s, long &amp;rank, Tensor&lt; typename Tensor&lt; T &gt;::scalar_type &gt; &amp;sumsq)</td></tr>
<tr class="memdesc:ga77bb5f0d7489b133019bf5f1a7a99368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve Ax = b for general A using the LAPACK *gelss routines.  <a href="#ga77bb5f0d7489b133019bf5f1a7a99368">More...</a><br /></td></tr>
<tr class="separator:ga77bb5f0d7489b133019bf5f1a7a99368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa1040ea790164d2920d41e9b4ec3fc2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gafa1040ea790164d2920d41e9b4ec3fc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linalg.html#gafa1040ea790164d2920d41e9b4ec3fc2">madness::syev</a> (const Tensor&lt; T &gt; &amp;A, Tensor&lt; T &gt; &amp;<a class="el" href="tdse1d_8cc.html#ab415b5b3ab6a497599ef6958884a4ab7">V</a>, Tensor&lt; typename Tensor&lt; T &gt;::scalar_type &gt; &amp;e)</td></tr>
<tr class="memdesc:gafa1040ea790164d2920d41e9b4ec3fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real-symmetric or complex-Hermitian eigenproblem.  <a href="#gafa1040ea790164d2920d41e9b4ec3fc2">More...</a><br /></td></tr>
<tr class="separator:gafa1040ea790164d2920d41e9b4ec3fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27afd954228a021066ae01a3ac38f7d2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga27afd954228a021066ae01a3ac38f7d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linalg.html#ga27afd954228a021066ae01a3ac38f7d2">madness::sygv</a> (const Tensor&lt; T &gt; &amp;A, const Tensor&lt; T &gt; &amp;<a class="el" href="tdse1d_8cc.html#a9491de326f16c5cce8c064fb5098a07b">B</a>, int itype, Tensor&lt; T &gt; &amp;<a class="el" href="tdse1d_8cc.html#ab415b5b3ab6a497599ef6958884a4ab7">V</a>, Tensor&lt; typename Tensor&lt; T &gt;::scalar_type &gt; &amp;e)</td></tr>
<tr class="memdesc:ga27afd954228a021066ae01a3ac38f7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalized real-symmetric or complex-Hermitian eigenproblem.  <a href="#ga27afd954228a021066ae01a3ac38f7d2">More...</a><br /></td></tr>
<tr class="separator:ga27afd954228a021066ae01a3ac38f7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a209958f3b97d42c5c2ae2bdfbbaf6d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4a209958f3b97d42c5c2ae2bdfbbaf6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linalg.html#ga4a209958f3b97d42c5c2ae2bdfbbaf6d">madness::cholesky</a> (Tensor&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ga4a209958f3b97d42c5c2ae2bdfbbaf6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Cholesky factorization.  <a href="#ga4a209958f3b97d42c5c2ae2bdfbbaf6d">More...</a><br /></td></tr>
<tr class="separator:ga4a209958f3b97d42c5c2ae2bdfbbaf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb40325239dfa472cd7523c750b8ebcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linalg.html#gaeb40325239dfa472cd7523c750b8ebcc">madness::test_tensor_lapack</a> ()</td></tr>
<tr class="memdesc:gaeb40325239dfa472cd7523c750b8ebcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test the Tensor-LAPACK interface ... currently always returns true!  <a href="#gaeb40325239dfa472cd7523c750b8ebcc">More...</a><br /></td></tr>
<tr class="separator:gaeb40325239dfa472cd7523c750b8ebcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59e5d613749fd9d3de9cf448c8282f85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linalg.html#ga59e5d613749fd9d3de9cf448c8282f85">madness::init_tensor_lapack</a> ()</td></tr>
<tr class="memdesc:ga59e5d613749fd9d3de9cf448c8282f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">World/MRA initialization calls this before going multithreaded due to static data in <code>dlamch</code>.  <a href="#ga59e5d613749fd9d3de9cf448c8282f85">More...</a><br /></td></tr>
<tr class="separator:ga59e5d613749fd9d3de9cf448c8282f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga4a209958f3b97d42c5c2ae2bdfbbaf6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void madness::cholesky </td>
          <td>(</td>
          <td class="paramtype">Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Cholesky factorization. </p>
<p>Cholesky factorization.</p>
<p>Compute the Cholesky factorization of the symmetric positive definite matrix A</p>
<p>For memory efficiency A is modified inplace. Its upper triangle will hold the result and the lower trianlge will be zeroed such that input = inner(transpose(output),output).</p>

<p>References <a class="el" href="clapack_8h.html#ace0039648e58c3803df0ff95d6d2e68c">dpotrf_()</a>, and <a class="el" href="tensorexcept_8h.html#a2d3bb3646d0996a33f0161d3f67d85f9">TENSOR_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="namespacemadness.html#aa76fe53e8929cd4a2a253e93b4790825">madness::test_cholesky()</a>.</p>

</div>
</div>
<a class="anchor" id="ga77bb5f0d7489b133019bf5f1a7a99368"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void madness::gelss </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor&lt; typename Tensor&lt; T &gt;::scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor&lt; typename Tensor&lt; T &gt;::scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>sumsq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve Ax = b for general A using the LAPACK *gelss routines. </p>
<p>Solves linear equations using least squares.</p>
<p>A should be a matrix (float, double, float_complex, double_complex) and b should be either a vector, or a matrix with each vector stored in a column (i.e., b[n,nrhs]).</p>
<p>If the LAPACK routine fails, it throws a <a class="el" href="classmadness_1_1TensorException.html" title="Tensor is intended to throw only TensorExceptions. ">TensorException</a> with the LAPACK info as the value. Otherwise, it returns the solution(s). The input A and b are unchanged. There is no need to worry about Python/C/Fortran ordering issues. It will solve Ax=b as written.</p>
<p>This from the LAPACK documentation </p><pre class="fragment">RCOND   (input) REAL
RCOND is used to determine the effective  rank  of A.
Singular values S(i) &lt;= RCOND*S(1) are treated
as zero.  If RCOND &lt; 0, machine precision is  used
instead.

RANK    (output) INTEGER
The  effective rank of A, i.e., the number of singular
values which are greater than RCOND*S(1).
</pre><p>Finally, the optional vector sumsq will store the sum-of-squares residual in the case of a rectangular matrix (least squares regression).</p>

<p>References <a class="el" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a()</a>, <a class="el" href="y1_8cc.html#a8edb09333aecbc60d69c0ce58542e31d">b()</a>, <a class="el" href="namespacemadness.html#a51a0751f3bf95a504c43be228e01b7c2">madness::copy()</a>, <a class="el" href="lapack_8cc.html#a37916d7e9ee36b7d6d130bdb929a0e59">dgelss_()</a>, <a class="el" href="gfit_8cc.html#a9990e99e87d163c58817550b21d35a83">m</a>, <a class="el" href="lda_8h.html#affe776513b24d84b39af8ab0930fef7f">max</a>, <a class="el" href="namespacempfr.html#a2af1d07e9af8f34253c984e1deab55b8">mpfr::min()</a>, <a class="el" href="tensorexcept_8h.html#a2d3bb3646d0996a33f0161d3f67d85f9">TENSOR_ASSERT</a>, and <a class="el" href="group__tensor.html#gae674b4cfcc0781d9a5319a1dbefd868b">madness::transpose()</a>.</p>

<p>Referenced by <a class="el" href="namespacemadness.html#aedfe582e1c372d945a4de2a05130f84e">madness::GMRES()</a>, <a class="el" href="kain_8cc.html#a8882fc790b887dea8e913c48cbdb4f30">KAIN()</a>, <a class="el" href="group__solvers.html#ga4c060fd40e19676a014b2b6fc5efa0a5">madness::KAIN()</a>, <a class="el" href="gfit_8cc.html#aad148260e3cd5075fbf7a41ff980972d">optimize_coeffs()</a>, and <a class="el" href="namespacemadness.html#a31f80bccc034b6fd4089cf87e347e766">madness::test_gelss()</a>.</p>

</div>
</div>
<a class="anchor" id="ga865ca226164574b67f1f7ff6fe75eef5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void madness::gesv </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve Ax = b for general A using the LAPACK *gesv routines. </p>
<p>Solves linear equations.</p>
<p>A should be a square matrix (float, double, float_complex, double_complex) and b should be either a vector, or a matrix with each vector stored in a column (i.e., b[n,nrhs]).</p>
<p>If the LAPACK routine fails, it throws a <a class="el" href="classmadness_1_1TensorException.html" title="Tensor is intended to throw only TensorExceptions. ">TensorException</a> with the LAPACK info as the value. Otherwise, it returns the solution(s). The input A and b are unchanged. There is no need to worry about Python/C/Fortran ordering issues. It will solve Ax=b as written.</p>

<p>References <a class="el" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a()</a>, <a class="el" href="y1_8cc.html#a8edb09333aecbc60d69c0ce58542e31d">b()</a>, <a class="el" href="namespacemadness.html#a51a0751f3bf95a504c43be228e01b7c2">madness::copy()</a>, <a class="el" href="lapack_8cc.html#af938f2f31fb4f17a6ccf6a17f99c928b">dgesv_()</a>, <a class="el" href="gfit_8cc.html#a9990e99e87d163c58817550b21d35a83">m</a>, <a class="el" href="tensorexcept_8h.html#a2d3bb3646d0996a33f0161d3f67d85f9">TENSOR_ASSERT</a>, and <a class="el" href="group__tensor.html#gae674b4cfcc0781d9a5319a1dbefd868b">madness::transpose()</a>.</p>

<p>Referenced by <a class="el" href="namespacemadness.html#a924f7da5b3feef880bc0a626ba0cb787">madness::gesvp()</a>, and <a class="el" href="namespacemadness.html#a043596239ea7ef21ead8f76ffff5aa9a">madness::test_gesv()</a>.</p>

</div>
</div>
<a class="anchor" id="ga59e5d613749fd9d3de9cf448c8282f85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void madness::init_tensor_lapack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>World/MRA initialization calls this before going multithreaded due to static data in <code>dlamch</code>. </p>

<p>References <a class="el" href="clapack_8h.html#a5414b76e64346c9147a52c119112eeb9">dlamch_()</a>, and <a class="el" href="clapack_8h.html#a8cf8de8e0b77550528b1b0c5309d1dc9">slamch_()</a>.</p>

<p>Referenced by <a class="el" href="namespacemadness.html#a42bc128272135fe2e19ec126fa018ae3">madness::startup()</a>.</p>

</div>
</div>
<a class="anchor" id="ga90a353ae981da60c007a5eab9e8e1670"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void madness::svd </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor&lt; typename Tensor&lt; T &gt;::scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>VT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the singluar value decomposition of an n-by-m matrix using *gesvd. </p>
<p>Computes singular value decomposition of matrix.</p>
<p>Returns via arguments U, s, VT where</p>
<p>A = U * diag(s) * VT for A real A = U * diag(s) * VH for A complex</p>
<p>or</p>
<p>UT * A * V = diag(s) for A real UH * A * V = diag(s) for A complex</p>
<p>If A is [m,n] and r=min(m,n) then we have U[m,r], s[r], and VT[r,n]</p>
<p>On failure, throws <a class="el" href="classmadness_1_1TensorException.html" title="Tensor is intended to throw only TensorExceptions. ">TensorException</a> with value set to Lapack's info.</p>

<p>References <a class="el" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a()</a>, <a class="el" href="namespacemadness.html#a51a0751f3bf95a504c43be228e01b7c2">madness::copy()</a>, <a class="el" href="lapack_8cc.html#a2c8379e90fb13fc24295f9970ad5b295">dgesvd_()</a>, <a class="el" href="gfit_8cc.html#a9990e99e87d163c58817550b21d35a83">m</a>, <a class="el" href="lda_8h.html#affe776513b24d84b39af8ab0930fef7f">max</a>, <a class="el" href="namespacempfr.html#a2af1d07e9af8f34253c984e1deab55b8">mpfr::min()</a>, and <a class="el" href="tensorexcept_8h.html#a2d3bb3646d0996a33f0161d3f67d85f9">TENSOR_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="structmadness_1_1ConvolutionData1D.html#a21f8175275fe0f17503adff7455acdfe">madness::ConvolutionData1D&lt; Q &gt;::make_approx()</a>, <a class="el" href="namespacemadness.html#af404ad1d6503806274501ae3dd4c3f15">madness::ortho3()</a>, <a class="el" href="namespacemadness.html#a9a1932bae5db79b0e070edae8e1e4695">madness::ortho5()</a>, <a class="el" href="namespacemadness.html#aa0dbf50b63a8dde5690e34a998d55481">madness::test_svd()</a>, and <a class="el" href="classmadness_1_1TensorTrain.html#ab62d04004da0dbe21aafd28b518b3921">madness::TensorTrain&lt; T &gt;::truncate()</a>.</p>

</div>
</div>
<a class="anchor" id="ga131173fdb385d4e6ceef5f38d5f27ccc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void madness::svd_result </td>
          <td>(</td>
          <td class="paramtype">Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor&lt; typename Tensor&lt; T &gt;::scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>same as svd, but it optimizes away the tensor construction: a = U * diag(s) * VT </p>
<p>note that S and VT are swapped in the calling list for c/fortran consistency! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>a (m,n) matrix to be svd'ed; upon return will hold VT the first min(m,n) rows of VT, stored rowwise </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">U</td><td>left singular vectors, stored columnwise </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td>the singular values </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VT</td><td>not referenced </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">work</td><td>work array; optimial length lwork: lwork = max&lt;integer&gt;(3*min(m,n)+max(m,n),5*min(m,n)-4)*32; </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a()</a>, <a class="el" href="lapack_8cc.html#a2c8379e90fb13fc24295f9970ad5b295">dgesvd_()</a>, <a class="el" href="gfit_8cc.html#a9990e99e87d163c58817550b21d35a83">m</a>, and <a class="el" href="tensorexcept_8h.html#a2d3bb3646d0996a33f0161d3f67d85f9">TENSOR_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="classmadness_1_1TensorTrain.html#a90d944b26211025cd9182bc6cb7ad1bf">madness::TensorTrain&lt; T &gt;::decompose()</a>.</p>

</div>
</div>
<a class="anchor" id="gafa1040ea790164d2920d41e9b4ec3fc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void madness::syev </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor&lt; typename Tensor&lt; T &gt;::scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real-symmetric or complex-Hermitian eigenproblem. </p>
<p>Solves symmetric or Hermitian eigenvalue problem.</p>
<p>A is a real symmetric or complex Hermitian matrix. Return V and e where V is a matrix whose columns are the eigenvectors and e is a vector containing the corresponding eigenvalues. If the LAPACK routine fails, it raises a <a class="el" href="classmadness_1_1TensorException.html" title="Tensor is intended to throw only TensorExceptions. ">TensorException</a> with value=infor. The input matrix is unchanged. The eigenvalues are sorted into ascending order. s/dsyev are used for real symmetric matrices; c/zheev are used for complex Hermitian.</p>
<p>The reults will satisfy A*V(_,i) = V(_,i)*e(i).</p>

<p>References <a class="el" href="lapack_8cc.html#a68842a30b6f11aa610860c02609fc5c2">dsyev_()</a>, <a class="el" href="lda_8h.html#affe776513b24d84b39af8ab0930fef7f">max</a>, <a class="el" href="tensorexcept_8h.html#a2d3bb3646d0996a33f0161d3f67d85f9">TENSOR_ASSERT</a>, and <a class="el" href="group__tensor.html#gae674b4cfcc0781d9a5319a1dbefd868b">madness::transpose()</a>.</p>

<p>Referenced by <a class="el" href="classmadness_1_1Solver.html#a1f2c969517d31d21f175c60b2736a3c7">madness::Solver&lt; T, NDIM &gt;::csqrt()</a>, <a class="el" href="classmadness_1_1Solver.html#a90e6106eba8815aeb37af86c29eb8ef0">madness::Solver&lt; T, NDIM &gt;::initial_guess()</a>, <a class="el" href="classMolecule.html#a8bc902aff3ab0d8fbcb01c04dfbc7584">Molecule::orient()</a>, <a class="el" href="classmadness_1_1Molecule.html#a8bc902aff3ab0d8fbcb01c04dfbc7584">madness::Molecule::orient()</a>, <a class="el" href="namespacemadness.html#af404ad1d6503806274501ae3dd4c3f15">madness::ortho3()</a>, <a class="el" href="namespacemadness.html#a9a1932bae5db79b0e070edae8e1e4695">madness::ortho5()</a>, <a class="el" href="classmadness_1_1Solver.html#a5c2b4723ce7854bc3a399f823861398b">madness::Solver&lt; T, NDIM &gt;::print_fock_matrix_eigs()</a>, <a class="el" href="classmadness_1_1Solver.html#ae0a166f1f4c7d8fc87022c3abbc91b15">madness::Solver&lt; T, NDIM &gt;::solve()</a>, <a class="el" href="moldft-elem_8cc.html#a8c9558c8bbbb3f02f973eaf59bd7604a">sqrt()</a>, and <a class="el" href="namespacemadness.html#a5f87fb9811af0453ed7bfce489a3441a">madness::test_syev()</a>.</p>

</div>
</div>
<a class="anchor" id="ga27afd954228a021066ae01a3ac38f7d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void madness::sygv </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor&lt; typename Tensor&lt; T &gt;::scalar_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generalized real-symmetric or complex-Hermitian eigenproblem. </p>
<p>Solves symmetric or Hermitian generalized eigenvalue problem.</p>
<p>This from the LAPACK documentation</p>
<pre class="fragment">S/DSYGV computes all the eigenvalues, and optionally, the eigenvectors
of a real generalized symmetric-definite eigenproblem, of the form
A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.  Here A and B
are assumed to be symmetric and B is also positive definite.

C/ZHEGV computes all the eigenvalues, and optionally, the eigenvectors
of a complex generalized Hermitian-definite eigenproblem, of the form
A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and B
are assumed to be Hermitian and B is also positive definite.

ITYPE   (input) INTEGER
Specifies the problem type to be solved:
= 1:  A*x = (lambda)*B*x
= 2:  A*B*x = (lambda)*x
= 3:  B*A*x = (lambda)*x
</pre>
<p>References <a class="el" href="y1_8cc.html#a8edb09333aecbc60d69c0ce58542e31d">b()</a>, <a class="el" href="lapack_8cc.html#a64d5a1ee54ab11a0fc12464ef63b6fdb">dsygv_()</a>, <a class="el" href="lda_8h.html#affe776513b24d84b39af8ab0930fef7f">max</a>, <a class="el" href="tensorexcept_8h.html#a2d3bb3646d0996a33f0161d3f67d85f9">TENSOR_ASSERT</a>, and <a class="el" href="group__tensor.html#gae674b4cfcc0781d9a5319a1dbefd868b">madness::transpose()</a>.</p>

<p>Referenced by <a class="el" href="structSCF.html#a8822af7eebd75788e870bafa2c644397">SCF::diag_fock_matrix()</a>, <a class="el" href="classmadness_1_1Solver.html#af34394cdb271dadf1b6f6a4077479405">madness::Solver&lt; T, NDIM &gt;::do_rhs()</a>, <a class="el" href="classmadness_1_1Solver.html#a12739ac28e5cf691ac761a3ce4bf1ed9">madness::Solver&lt; T, NDIM &gt;::do_rhs_simple()</a>, <a class="el" href="vnucso_8cc.html#adf578d7cad225799b890277aa09d9b43">doit()</a>, <a class="el" href="classmadness_1_1Solver.html#a90e6106eba8815aeb37af86c29eb8ef0">madness::Solver&lt; T, NDIM &gt;::initial_guess()</a>, <a class="el" href="classmadness_1_1Solver.html#a5c2b4723ce7854bc3a399f823861398b">madness::Solver&lt; T, NDIM &gt;::print_fock_matrix_eigs()</a>, <a class="el" href="classmadness_1_1Solver.html#a760b8a41dd132f093f8a9eba97e0d9e9">madness::Solver&lt; T, NDIM &gt;::print_potential_matrix_eigs()</a>, <a class="el" href="namespacemadness.html#afbf1eb6adda3449f43baa1e9a40ce1a6">madness::sygvp()</a>, and <a class="el" href="namespacemadness.html#a5455feacd3a0a6a387d4cae76a51cca6">madness::test_sygv()</a>.</p>

</div>
</div>
<a class="anchor" id="gaeb40325239dfa472cd7523c750b8ebcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool madness::test_tensor_lapack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test the Tensor-LAPACK interface ... currently always returns true! </p>
<p>Dunno.</p>
<p>Runs the tensor test code, returns true on success </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 26 2014 10:39:31 for MADNESS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
