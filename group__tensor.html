<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>MADNESS: Tensors or multidimension arrays</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MADNESS
   &#160;<span id="projectnumber">version 0.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tensors or multidimension arrays<div class="ingroups"><a class="el" href="group__libraries.html">MADNESS libraries</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Tensors or multidimension arrays:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__tensor.png" border="0" alt="" usemap="#group____tensor"/>
<map name="group____tensor" id="group____tensor">
<area shape="rect" id="node1" href="group__function.html" title="Function" alt="" coords="533,5,610,33"/><area shape="rect" id="node2" href="group__parallel__runtime.html" title="Parallel programming\l environment" alt="" coords="491,57,652,101"/><area shape="rect" id="node4" href="group__libraries.html" title="MADNESS libraries" alt="" coords="5,36,145,64"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:slice_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice_8h.html">slice.h</a></td></tr>
<tr class="memdesc:slice_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares and implements Slice. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:tensor_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tensor_8cc.html">tensor.cc</a></td></tr>
<tr class="memdesc:tensor_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes the implementation of Tensor and instantiates all specializations for fast compiles. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:tensor_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tensor_8h.html">tensor.h</a></td></tr>
<tr class="memdesc:tensor_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and implements most of Tensor. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:tensor__macros_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tensor__macros_8h.html">tensor_macros.h</a></td></tr>
<tr class="memdesc:tensor__macros_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macros for easy and efficient iteration over tensors. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:tensortrain_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tensortrain_8h.html">tensortrain.h</a></td></tr>
<tr class="memdesc:tensortrain_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and implements the tensor train decomposition as described in I.V. Oseledets, Siam J. Sci. Comput. 33, 2295 (2011). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemadness"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemadness.html">madness</a></td></tr>
<tr class="memdesc:namespacemadness"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds machinery to set up Functions/FuncImpls using various Factories and Interfaces. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1BaseTensor.html">madness::BaseTensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for tensors defines generic capabilities.  <a href="classmadness_1_1BaseTensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1Slice.html">madness::Slice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slice defines a sub-range or patch of a dimension.  <a href="classmadness_1_1Slice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1TensorException.html">madness::TensorException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor is intended to throw only TensorExceptions.  <a href="classmadness_1_1TensorException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1TensorIterator.html">madness::TensorIterator&lt; T, Q, R &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga819bde0edb797aaf642184f9d461edca"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga819bde0edb797aaf642184f9d461edca"><td class="memTemplItemLeft" align="right" valign="top">GenTensor&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tensor.html#ga819bde0edb797aaf642184f9d461edca">madness::outer</a> (const GenTensor&lt; T &gt; &amp;left, const GenTensor&lt; T &gt; &amp;right)</td></tr>
<tr class="memdesc:ga819bde0edb797aaf642184f9d461edca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outer product ... result(i,j,...,p,q,...) = left(i,k,...)*right(p,q,...)  <a href="#ga819bde0edb797aaf642184f9d461edca">More...</a><br /></td></tr>
<tr class="separator:ga819bde0edb797aaf642184f9d461edca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32104e2daa59a9df556bba500e24fa8e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga32104e2daa59a9df556bba500e24fa8e"><td class="memTemplItemLeft" align="right" valign="top">GenTensor&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tensor.html#ga32104e2daa59a9df556bba500e24fa8e">madness::outer_low_rank</a> (const Tensor&lt; T &gt; &amp;left, const Tensor&lt; T &gt; &amp;right)</td></tr>
<tr class="memdesc:ga32104e2daa59a9df556bba500e24fa8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outer product ... result(i,j,...,p,q,...) = left(i,k,...)*right(p,q,...)  <a href="#ga32104e2daa59a9df556bba500e24fa8e">More...</a><br /></td></tr>
<tr class="separator:ga32104e2daa59a9df556bba500e24fa8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50c2930438aa659d6381f667951c69da"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Q &gt; </td></tr>
<tr class="memitem:ga50c2930438aa659d6381f667951c69da"><td class="memTemplItemLeft" align="right" valign="top">IsSupported&lt; TensorTypeData&lt; Q &gt;<br class="typebreak" />
, Tensor&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tensor.html#ga50c2930438aa659d6381f667951c69da">madness::operator+</a> (Q x, const Tensor&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:ga50c2930438aa659d6381f667951c69da"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class defines tensor op scalar ... here define scalar op tensor.  <a href="#ga50c2930438aa659d6381f667951c69da">More...</a><br /></td></tr>
<tr class="separator:ga50c2930438aa659d6381f667951c69da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60dc017e21558ad38f77997514ada97e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Q &gt; </td></tr>
<tr class="memitem:ga60dc017e21558ad38f77997514ada97e"><td class="memTemplItemLeft" align="right" valign="top">IsSupported&lt; TensorTypeData&lt; Q &gt;<br class="typebreak" />
, Tensor&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tensor.html#ga60dc017e21558ad38f77997514ada97e">madness::operator*</a> (const Q &amp;x, const Tensor&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:ga60dc017e21558ad38f77997514ada97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class defines tensor op scalar ... here define scalar op tensor.  <a href="#ga60dc017e21558ad38f77997514ada97e">More...</a><br /></td></tr>
<tr class="separator:ga60dc017e21558ad38f77997514ada97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4207f3974c2c7b2090334147b7582d4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Q &gt; </td></tr>
<tr class="memitem:gad4207f3974c2c7b2090334147b7582d4"><td class="memTemplItemLeft" align="right" valign="top">IsSupported&lt; TensorTypeData&lt; Q &gt;<br class="typebreak" />
, Tensor&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tensor.html#gad4207f3974c2c7b2090334147b7582d4">madness::operator-</a> (Q x, const Tensor&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:gad4207f3974c2c7b2090334147b7582d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class defines tensor op scalar ... here define scalar op tensor.  <a href="#gad4207f3974c2c7b2090334147b7582d4">More...</a><br /></td></tr>
<tr class="separator:gad4207f3974c2c7b2090334147b7582d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebaf7b8bf6d39f7509fea10613863258"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaebaf7b8bf6d39f7509fea10613863258"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tensor.html#gaebaf7b8bf6d39f7509fea10613863258">madness::copy</a> (const Tensor&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:gaebaf7b8bf6d39f7509fea10613863258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new contiguous tensor that is a deep copy of the input.  <a href="#gaebaf7b8bf6d39f7509fea10613863258">More...</a><br /></td></tr>
<tr class="separator:gaebaf7b8bf6d39f7509fea10613863258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacab686d57a7139600308698eb2b4abf6"><td class="memTemplParams" colspan="2">template&lt;class T , class Q &gt; </td></tr>
<tr class="memitem:gacab686d57a7139600308698eb2b4abf6"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; <a class="el" href="type__data_8h.html#ad89485f5bdd3c92f606c723d4d392cb0">TENSOR_RESULT_TYPE</a>(T, Q)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tensor.html#gacab686d57a7139600308698eb2b4abf6">madness::transform_dir</a> (const Tensor&lt; T &gt; &amp;t, const Tensor&lt; Q &gt; &amp;<a class="el" href="gfit_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>, int axis)</td></tr>
<tr class="memdesc:gacab686d57a7139600308698eb2b4abf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms one dimension of the tensor t by the matrix c, returns new contiguous tensor.  <a href="#gacab686d57a7139600308698eb2b4abf6">More...</a><br /></td></tr>
<tr class="separator:gacab686d57a7139600308698eb2b4abf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae674b4cfcc0781d9a5319a1dbefd868b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gae674b4cfcc0781d9a5319a1dbefd868b"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tensor.html#gae674b4cfcc0781d9a5319a1dbefd868b">madness::transpose</a> (const Tensor&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:gae674b4cfcc0781d9a5319a1dbefd868b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new deep copy of the transpose of the input tensor.  <a href="#gae674b4cfcc0781d9a5319a1dbefd868b">More...</a><br /></td></tr>
<tr class="separator:gae674b4cfcc0781d9a5319a1dbefd868b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e7c149a5c2a15a7e084499e0b6105d8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga3e7c149a5c2a15a7e084499e0b6105d8"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tensor.html#ga3e7c149a5c2a15a7e084499e0b6105d8">madness::conj_transpose</a> (const Tensor&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:ga3e7c149a5c2a15a7e084499e0b6105d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new deep copy of the complex conjugate transpose of the input tensor.  <a href="#ga3e7c149a5c2a15a7e084499e0b6105d8">More...</a><br /></td></tr>
<tr class="separator:ga3e7c149a5c2a15a7e084499e0b6105d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga188a6d50fd0ad90404e7f31b06ea4a9a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga188a6d50fd0ad90404e7f31b06ea4a9a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tensor.html#ga188a6d50fd0ad90404e7f31b06ea4a9a">madness::operator&lt;&lt;</a> (std::ostream &amp;s, const Tensor&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:ga188a6d50fd0ad90404e7f31b06ea4a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print (for human consumption) a tensor to the stream.  <a href="#ga188a6d50fd0ad90404e7f31b06ea4a9a">More...</a><br /></td></tr>
<tr class="separator:ga188a6d50fd0ad90404e7f31b06ea4a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c36eca58b8a5c593b0443d0f8ec63aa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga3c36eca58b8a5c593b0443d0f8ec63aa"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tensor.html#ga3c36eca58b8a5c593b0443d0f8ec63aa">madness::outer</a> (const Tensor&lt; T &gt; &amp;left, const Tensor&lt; T &gt; &amp;right)</td></tr>
<tr class="memdesc:ga3c36eca58b8a5c593b0443d0f8ec63aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outer product ... result(i,j,...,p,q,...) = left(i,k,...)*right(p,q,...)  <a href="#ga3c36eca58b8a5c593b0443d0f8ec63aa">More...</a><br /></td></tr>
<tr class="separator:ga3c36eca58b8a5c593b0443d0f8ec63aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7141b1a1d6a655cfcb159dff23debdf"><td class="memTemplParams" colspan="2">template&lt;class T , class Q &gt; </td></tr>
<tr class="memitem:gac7141b1a1d6a655cfcb159dff23debdf"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; <a class="el" href="type__data_8h.html#ad89485f5bdd3c92f606c723d4d392cb0">TENSOR_RESULT_TYPE</a>(T, Q)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tensor.html#gac7141b1a1d6a655cfcb159dff23debdf">madness::inner</a> (const Tensor&lt; T &gt; &amp;left, const Tensor&lt; Q &gt; &amp;right, long k0=-1, long k1=0)</td></tr>
<tr class="memdesc:gac7141b1a1d6a655cfcb159dff23debdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inner product ... result(i,j,...,p,q,...) = sum(z) left(i,j,...,z)*right(z,p,q,...)  <a href="#gac7141b1a1d6a655cfcb159dff23debdf">More...</a><br /></td></tr>
<tr class="separator:gac7141b1a1d6a655cfcb159dff23debdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga840d462d1f6f9b2f42ff7ff131323395"><td class="memTemplParams" colspan="2">template&lt;class T , class Q &gt; </td></tr>
<tr class="memitem:ga840d462d1f6f9b2f42ff7ff131323395"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tensor.html#ga840d462d1f6f9b2f42ff7ff131323395">madness::inner_result</a> (const Tensor&lt; T &gt; &amp;left, const Tensor&lt; Q &gt; &amp;right, long k0, long k1, Tensor&lt; <a class="el" href="type__data_8h.html#ad89485f5bdd3c92f606c723d4d392cb0">TENSOR_RESULT_TYPE</a>(T, Q) &gt; &amp;result)</td></tr>
<tr class="memdesc:ga840d462d1f6f9b2f42ff7ff131323395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate inner product into user provided, contiguous, correctly sized result tensor.  <a href="#ga840d462d1f6f9b2f42ff7ff131323395">More...</a><br /></td></tr>
<tr class="separator:ga840d462d1f6f9b2f42ff7ff131323395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d20c4bd2d94810775fbdf801ee7eeac"><td class="memTemplParams" colspan="2">template&lt;class T , class Q &gt; </td></tr>
<tr class="memitem:ga3d20c4bd2d94810775fbdf801ee7eeac"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; <a class="el" href="type__data_8h.html#ad89485f5bdd3c92f606c723d4d392cb0">TENSOR_RESULT_TYPE</a>(T, Q)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tensor.html#ga3d20c4bd2d94810775fbdf801ee7eeac">madness::transform</a> (const Tensor&lt; T &gt; &amp;t, const Tensor&lt; Q &gt; &amp;<a class="el" href="gfit_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>)</td></tr>
<tr class="memdesc:ga3d20c4bd2d94810775fbdf801ee7eeac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform all dimensions of the tensor t by the matrix c.  <a href="#ga3d20c4bd2d94810775fbdf801ee7eeac">More...</a><br /></td></tr>
<tr class="separator:ga3d20c4bd2d94810775fbdf801ee7eeac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15d1a8d4059cb71a3028e3e5e548ab2f"><td class="memTemplParams" colspan="2">template&lt;class T , class Q &gt; </td></tr>
<tr class="memitem:ga15d1a8d4059cb71a3028e3e5e548ab2f"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; <a class="el" href="type__data_8h.html#ad89485f5bdd3c92f606c723d4d392cb0">TENSOR_RESULT_TYPE</a>(T, Q)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tensor.html#ga15d1a8d4059cb71a3028e3e5e548ab2f">madness::general_transform</a> (const Tensor&lt; T &gt; &amp;t, const Tensor&lt; Q &gt; <a class="el" href="gfit_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>[])</td></tr>
<tr class="memdesc:ga15d1a8d4059cb71a3028e3e5e548ab2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform all dimensions of the tensor t by distinct matrices c.  <a href="#ga15d1a8d4059cb71a3028e3e5e548ab2f">More...</a><br /></td></tr>
<tr class="separator:ga15d1a8d4059cb71a3028e3e5e548ab2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d9a64acdea379a5d7df62b88c25ee97"><td class="memTemplParams" colspan="2">template&lt;class T , class Q &gt; </td></tr>
<tr class="memitem:ga7d9a64acdea379a5d7df62b88c25ee97"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; <a class="el" href="type__data_8h.html#ad89485f5bdd3c92f606c723d4d392cb0">TENSOR_RESULT_TYPE</a>(T, <br class="typebreak" />
Q) &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tensor.html#ga7d9a64acdea379a5d7df62b88c25ee97">madness::fast_transform</a> (const Tensor&lt; T &gt; &amp;t, const Tensor&lt; Q &gt; &amp;<a class="el" href="gfit_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>, Tensor&lt; <a class="el" href="type__data_8h.html#ad89485f5bdd3c92f606c723d4d392cb0">TENSOR_RESULT_TYPE</a>(T, Q) &gt; &amp;result, Tensor&lt; <a class="el" href="type__data_8h.html#ad89485f5bdd3c92f606c723d4d392cb0">TENSOR_RESULT_TYPE</a>(T, Q) &gt; &amp;workspace)</td></tr>
<tr class="memdesc:ga7d9a64acdea379a5d7df62b88c25ee97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricted but heavily optimized form of <a class="el" href="namespacemadness.html#afcde52e430e0a853237e4938b27ca771">transform()</a>  <a href="#ga7d9a64acdea379a5d7df62b88c25ee97">More...</a><br /></td></tr>
<tr class="separator:ga7d9a64acdea379a5d7df62b88c25ee97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83ed093a28e8da1b1a1d3850d957d148"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga83ed093a28e8da1b1a1d3850d957d148"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; typename Tensor&lt; T &gt;<br class="typebreak" />
::scalar_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tensor.html#ga83ed093a28e8da1b1a1d3850d957d148">madness::abs</a> (const Tensor&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:ga83ed093a28e8da1b1a1d3850d957d148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new tensor holding the absolute value of each element of t.  <a href="#ga83ed093a28e8da1b1a1d3850d957d148">More...</a><br /></td></tr>
<tr class="separator:ga83ed093a28e8da1b1a1d3850d957d148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa45c2e0d1550810e102c45eee318b16"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaaa45c2e0d1550810e102c45eee318b16"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; typename Tensor&lt; T &gt;<br class="typebreak" />
::scalar_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tensor.html#gaaa45c2e0d1550810e102c45eee318b16">madness::arg</a> (const Tensor&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:gaaa45c2e0d1550810e102c45eee318b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new tensor holding the argument of each element of t (complex types only)  <a href="#gaaa45c2e0d1550810e102c45eee318b16">More...</a><br /></td></tr>
<tr class="separator:gaaa45c2e0d1550810e102c45eee318b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga569b463a16f2617e188e37ea8cb78279"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga569b463a16f2617e188e37ea8cb78279"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; typename Tensor&lt; T &gt;<br class="typebreak" />
::scalar_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tensor.html#ga569b463a16f2617e188e37ea8cb78279">madness::real</a> (const Tensor&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:ga569b463a16f2617e188e37ea8cb78279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new tensor holding the real part of each element of t (complex types only)  <a href="#ga569b463a16f2617e188e37ea8cb78279">More...</a><br /></td></tr>
<tr class="separator:ga569b463a16f2617e188e37ea8cb78279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada3ed3011f4c87354995910e2632a6ed"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gada3ed3011f4c87354995910e2632a6ed"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; typename Tensor&lt; T &gt;<br class="typebreak" />
::scalar_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tensor.html#gada3ed3011f4c87354995910e2632a6ed">madness::imag</a> (const Tensor&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:gada3ed3011f4c87354995910e2632a6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new tensor holding the imaginary part of each element of t (complex types only)  <a href="#gada3ed3011f4c87354995910e2632a6ed">More...</a><br /></td></tr>
<tr class="separator:gada3ed3011f4c87354995910e2632a6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc3f220fb52eef61edd94d13aef01fa1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gafc3f220fb52eef61edd94d13aef01fa1"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tensor.html#gafc3f220fb52eef61edd94d13aef01fa1">madness::conj</a> (const Tensor&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:gafc3f220fb52eef61edd94d13aef01fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new deep copy of the complex conjugate of the input tensor (complex types only)  <a href="#gafc3f220fb52eef61edd94d13aef01fa1">More...</a><br /></td></tr>
<tr class="separator:gafc3f220fb52eef61edd94d13aef01fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad15fdd7b42d8efddf8a24f7d7f8d4130"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tensor.html#gad15fdd7b42d8efddf8a24f7d7f8d4130">madness::TensorIterator&lt; T, Q, R &gt;::TensorIterator</a> (const Tensor&lt; T &gt; *t0, const Tensor&lt; Q &gt; *t1=0, const Tensor&lt; <a class="el" href="svpe_8cc.html#a0877420f3d7b1f47b871d2ccb47168d8">R</a> &gt; *t2=0, long iterlevel=0, bool optimize=true, bool fusedim=true, long jdim=default_jdim)</td></tr>
<tr class="memdesc:gad15fdd7b42d8efddf8a24f7d7f8d4130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for general iterator to compose operations over up to three tensors.  <a href="#gad15fdd7b42d8efddf8a24f7d7f8d4130">More...</a><br /></td></tr>
<tr class="separator:gad15fdd7b42d8efddf8a24f7d7f8d4130"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="section user"><dt>Introduction</dt><dd></dd></dl>
<p>A tensor is a multi-dimensional array and does not incorporate any concepts of covariance and contravariance.</p>
<p>When a new tensor is created, the underlying data is also allocated. E.g., </p><div class="fragment"><div class="line">Tensor&lt;double&gt; <a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>(3,4,5)</div>
</div><!-- fragment --><p> creates a new 3-dimensional tensor and allocates a contiguous block of 60 doubles which are initialized to zero. The dimensions (numbered from the left starting at 0) are in C or row-major order. Thus, for the tensor <code>a</code> , the stride between successive elements of the right-most dimension is 1. For the middle dimension it is 5. For the left-most dimension it is 20. Thus, the loops </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;3; ++i)</div>
<div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;4; ++j)</div>
<div class="line">        <span class="keywordflow">for</span> (k=0; <a class="code" href="dielectric_8cc.html#aeac95f79b72f13ef3244522682ba9a21">k</a>&lt;5; ++<a class="code" href="dielectric_8cc.html#aeac95f79b72f13ef3244522682ba9a21">k</a>)</div>
<div class="line">            <a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>(i,j,k) = ...</div>
</div><!-- fragment --><p> will go sequentially (and thus efficiently) through memory. If the dimensions have been reordered (e.g., with <code>swapdim()</code> or <code>map()</code> ), or if the tensor is actually a slice of another tensor, then the layout in memory may be more complex and may not reflect a contiguous block of memory.</p>
<p>Multiple tensors may be used to provide multiple identical or distinct views of the same data. E.g., in the following </p><div class="fragment"><div class="line">Tensor&lt;double&gt; <a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>(2,3);  <span class="comment">// A new tensor initialized to zero</span></div>
<div class="line">Tensor&lt;double&gt; <a class="code" href="y1_8cc.html#a8edb09333aecbc60d69c0ce58542e31d">b</a> = <a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>;</div>
</div><!-- fragment --><p> <code>a</code> and <code>b</code> provide identical views of the same data, thus </p><div class="fragment"><div class="line"><a class="code" href="y1_8cc.html#a8edb09333aecbc60d69c0ce58542e31d">b</a>(1,2) = 99;</div>
<div class="line">cout &lt;&lt; <a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>(1,2) &lt;&lt; endl;  <span class="comment">// Outputs 99</span></div>
<div class="line">cout &lt;&lt; <a class="code" href="y1_8cc.html#a8edb09333aecbc60d69c0ce58542e31d">b</a>(1,2) &lt;&lt; endl;  <span class="comment">// Outputs 99</span></div>
</div><!-- fragment --><dl class="section user"><dt>Shallow copy and assignment</dt><dd></dd></dl>
<p>It is important to appreciate that the views and the data are quite independent. In particular, the default copy constructor and assignment operations only copy the tensor (the view) and not the data &mdash; <em> i.e., the copy constructor and assigment operations only take shallow copies</em>. This is for both consistency and efficiency. Thus, assigning one tensor to another generates another view of the same data, replacing any previous view and not moving or copying any of the data. E.g., </p><div class="fragment"><div class="line">Tensor&lt;double&gt; <a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>(2,3);   <span class="comment">// A new tensor initialized to zero</span></div>
<div class="line">Tensor&lt;double&gt; <a class="code" href="gfit_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>(3,3,3); <span class="comment">// Another new tensor</span></div>
<div class="line">Tensor&lt;double&gt; b = <a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>;    <span class="comment">// b is a view of the same data as a</span></div>
<div class="line">a = <a class="code" href="gfit_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>;                   <span class="comment">// a is now a view of c&#39;s data</span></div>
<div class="line">b = c                    <span class="comment">// b is now also a view of c&#39;s data and the</span></div>
<div class="line"><span class="comment">// data allocated originally for a is freed</span></div>
</div><!-- fragment --><p> The above example also illustrates how reference counting is used to keep track of the underlying data. Once there are no views of the data, it is automatically freed.</p>
<p>There are only two ways to actually copy the underlying data. A new, complete, and contigous copy of a tensor and its data may be generated with the <code><a class="el" href="group__tensor.html#gaebaf7b8bf6d39f7509fea10613863258" title="Returns a new contiguous tensor that is a deep copy of the input. ">copy()</a></code> function. Or, to copy data from one tensor into the data viewed by another tensor, you must use a Slice.</p>
<dl class="section user"><dt>Indexing</dt><dd></dd></dl>
<p>One dimensional tensors (i.e., vectors) may be indexed using either square brackets (e.g., <code>v</code>[i] ) or round brackets (e.g., <code>v(i)</code> ). All higher-dimensional tensors must use only round brackets (e.g., <code>t(i,j,k)</code> ). This is due to C++'s restriction that the indexing operator (<code></code>[] ) can only have one argument. The indexing operation should generate efficient code.</p>
<p>For the sake of efficiency, no bounds checking is performed by default by most single element indexing operations. Checking can be enabled at compile time by defining <code>-DTENSOR_BOUNDS_CHECKING</code> for application files including <code><a class="el" href="tensor_8h.html" title="Defines and implements most of Tensor. ">tensor.h</a></code>. The MADNESS configure script has the option <code>&ndash;enable-tensor-bound-checking</code> to define the macro in <code><a class="el" href="madness__config_8h.html">madness_config.h</a></code> . The general indexing operation that takes a <code>std::vector&lt;long&gt;</code> index and all slicing operations always perform bounds checking. To make indexing with checking a bit easier, a factory function has been provided for vectors ... but note you need to explicitly use longs as the index. </p><div class="fragment"><div class="line">Tensor&lt;long&gt; <a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>(7,7,7);</div>
<div class="line"><a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>(3,4,5) += 1;                    <span class="comment">// OK ... adds 1 to element (3,4,5)</span></div>
<div class="line"><a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>(3,4,9) += 1;                    <span class="comment">// BAD ... undetected out-of-bounds access</span></div>
<div class="line"><a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>(<a class="code" href="namespacemadness.html#a90122c2b7670e5206897a42cc7d6864c">vector_factory</a>(3L,4L,9L)) += 1; <span class="comment">// OK ... out-bounds access will</span></div>
<div class="line"><span class="comment">// be detected at runtime.</span></div>
</div><!-- fragment --><dl class="section user"><dt>Slicing</dt><dd></dd></dl>
<p>Slices generate sub-tensors &mdash; i.e., views of patches of the data. E.g., to refer to all but the first and last elements in each dimension of a matrix use </p><div class="fragment"><div class="line"><a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>(Slice(1,-2),Slice(1,-2))</div>
</div><!-- fragment --><p> Or to view odd elements in each dimension </p><div class="fragment"><div class="line"><a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>(Slice(0,-1,2),Slice(0,-1,2))</div>
</div><!-- fragment --><p> A slice or patch of a tensor behaves exactly like a tensor <em>except</em> for assignment. When a slice is assigned to, the data is copied with the requirement that the source and destinations agree in size and shape (i.e., they conform). Thus, to copy the all of the data from a to b, </p><div class="fragment"><div class="line">Tensor&lt;double&gt; <a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>(3,4), <a class="code" href="y1_8cc.html#a8edb09333aecbc60d69c0ce58542e31d">b</a>(3,4);</div>
<div class="line">a = 1;                              <span class="comment">// Set all elements of a to 1</span></div>
<div class="line">b = 2;                              <span class="comment">// Set all elements of b to 2</span></div>
<div class="line"><a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>(Slice(0,-1,1),Slice(0,-1,1)) = <a class="code" href="y1_8cc.html#a8edb09333aecbc60d69c0ce58542e31d">b</a>; <span class="comment">// Copy all data from b to a</span></div>
<div class="line"><a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>(_,_) = <a class="code" href="y1_8cc.html#a8edb09333aecbc60d69c0ce58542e31d">b</a>(_,_);                    <span class="comment">// Copy all data from b to a</span></div>
<div class="line"><a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>(___) = <a class="code" href="y1_8cc.html#a8edb09333aecbc60d69c0ce58542e31d">b</a>(___);                    <span class="comment">// Copy all data from b to a</span></div>
<div class="line"><a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>(Slice(1,2),Slice(1,2) = b;        <span class="comment">// Error, do not conform</span></div>
</div><!-- fragment --><p> Special slice values <code>_</code> ,<code>_reverse</code>, and <code>___</code> have been defined to refer to all elements in a dimension, all elements in a dimension but reversed, and all elements in all dimensions, respectively.</p>
<dl class="section user"><dt>Iteration and algorithms</dt><dd></dd></dl>
<p>See <a class="el" href="tensor__macros_8h.html" title="Macros for easy and efficient iteration over tensors. ">tensor_macros.h</a> for documentation on the easiest mechanisms for iteration over elements of tensors and tips for optimization. See <code>TensorIterator</code> for the most general form of iteration. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga83ed093a28e8da1b1a1d3850d957d148"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt; typename Tensor&lt;T&gt;::scalar_type &gt; madness::abs </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new tensor holding the absolute value of each element of t. </p>

<p>References <a class="el" href="tensor__macros_8h.html#ab4e453e4edbb844ab3ef9e4cb96e46d3">BINARY_OPTIMIZED_ITERATOR</a>.</p>

</div>
</div>
<a class="anchor" id="gaaa45c2e0d1550810e102c45eee318b16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt; typename Tensor&lt;T&gt;::scalar_type &gt; madness::arg </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new tensor holding the argument of each element of t (complex types only) </p>

<p>References <a class="el" href="tensor__macros_8h.html#ab4e453e4edbb844ab3ef9e4cb96e46d3">BINARY_OPTIMIZED_ITERATOR</a>.</p>

<p>Referenced by <a class="el" href="namespacemadness.html#ae331b95327f112617c5ee0f54c8d458a">madness::alloc_am_arg()</a>, <a class="el" href="classmadness_1_1World.html#a8f8af98e61a6dbeb5d3c9ac1490f9287">madness::World::args()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a28c6623a7488557200dccefddf5f056e">madness::FunctionImpl&lt; Q, NDIM &gt;::do_binary_op()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a2ec6ef2be180c2d529649ed5c6ee339c">madness::FunctionImpl&lt; Q, NDIM &gt;::do_mul()</a>, <a class="el" href="classmadness_1_1Solver.html#af34394cdb271dadf1b6f6a4077479405">madness::Solver&lt; T, NDIM &gt;::do_rhs()</a>, <a class="el" href="classmadness_1_1Solver.html#a12739ac28e5cf691ac761a3ce4bf1ed9">madness::Solver&lt; T, NDIM &gt;::do_rhs_simple()</a>, <a class="el" href="namespacemadness.html#a96a3e59db847104160a4bedb8396c6f8">madness::free_am_arg()</a>, <a class="el" href="classScatteringWF.html#ae455be66995a68cf49491a4ff4aac027">ScatteringWF::gamma()</a>, <a class="el" href="helium__exact_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, <a class="el" href="namespacemadness.html#a28f73c6bf6e4a22eec9ab9bfbd14ff92">madness::new_am_arg()</a>, <a class="el" href="namespacetesting_1_1internal.html#ae4c46ce8c3d016848fff52cc5133f2ac">testing::internal::ParseGoogleTestFlagsOnlyImpl()</a>, <a class="el" href="tdse1d_8cc.html#a6dfe75f8e9da63ddc55c6f075f54fdc1">psi_exact()</a>, <a class="el" href="namespacemadness.html#a42bc128272135fe2e19ec126fa018ae3">madness::startup()</a>, and <a class="el" href="singletonmadness_1_1FunctionImpl.html#a9221bbf6f22a05193cefe7d14bb5b69f">madness::FunctionImpl&lt; Q, NDIM &gt;::traverse_tree()</a>.</p>

</div>
</div>
<a class="anchor" id="gafc3f220fb52eef61edd94d13aef01fa1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt;T&gt; madness::conj </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new deep copy of the complex conjugate of the input tensor (complex types only) </p>

<p>References <a class="el" href="tensor__macros_8h.html#ab4e453e4edbb844ab3ef9e4cb96e46d3">BINARY_OPTIMIZED_ITERATOR</a>.</p>

</div>
</div>
<a class="anchor" id="ga3e7c149a5c2a15a7e084499e0b6105d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt;T&gt; madness::conj_transpose </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new deep copy of the complex conjugate transpose of the input tensor. </p>

<p>References <a class="el" href="namespacemadness.html#a29e4acc3bb0f63ef7b5fd8ac3fb34579">madness::conj()</a>, and <a class="el" href="tensorexcept_8h.html#a2d3bb3646d0996a33f0161d3f67d85f9">TENSOR_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="classmadness_1_1Solver.html#aaaa707c612cd2fb759c832487377e184">madness::Solver&lt; T, NDIM &gt;::build_fock_matrix()</a>, <a class="el" href="classmadness_1_1Solver.html#af34394cdb271dadf1b6f6a4077479405">madness::Solver&lt; T, NDIM &gt;::do_rhs()</a>, <a class="el" href="classmadness_1_1Solver.html#a12739ac28e5cf691ac761a3ce4bf1ed9">madness::Solver&lt; T, NDIM &gt;::do_rhs_simple()</a>, <a class="el" href="classmadness_1_1Solver.html#a90e6106eba8815aeb37af86c29eb8ef0">madness::Solver&lt; T, NDIM &gt;::initial_guess()</a>, <a class="el" href="namespacemadness.html#ae65fcc243f62c46319d76cf319d16470">madness::my_conj_transpose()</a>, and <a class="el" href="classmadness_1_1Solver.html#a5c2b4723ce7854bc3a399f823861398b">madness::Solver&lt; T, NDIM &gt;::print_fock_matrix_eigs()</a>.</p>

</div>
</div>
<a class="anchor" id="gaebaf7b8bf6d39f7509fea10613863258"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt;T&gt; madness::copy </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new contiguous tensor that is a deep copy of the input. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a new contiguous tensor that is a deep copy of the input </dd></dl>

<p>References <a class="el" href="tensor__macros_8h.html#ab4e453e4edbb844ab3ef9e4cb96e46d3">BINARY_OPTIMIZED_ITERATOR</a>.</p>

</div>
</div>
<a class="anchor" id="ga7d9a64acdea379a5d7df62b88c25ee97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Q &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt; <a class="el" href="type__data_8h.html#ad89485f5bdd3c92f606c723d4d392cb0">TENSOR_RESULT_TYPE</a>(T,Q) &gt;&amp; madness::fast_transform </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; Q &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor&lt; <a class="el" href="type__data_8h.html#ad89485f5bdd3c92f606c723d4d392cb0">TENSOR_RESULT_TYPE</a>(T, Q) &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor&lt; <a class="el" href="type__data_8h.html#ad89485f5bdd3c92f606c723d4d392cb0">TENSOR_RESULT_TYPE</a>(T, Q) &gt; &amp;&#160;</td>
          <td class="paramname"><em>workspace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restricted but heavily optimized form of <a class="el" href="namespacemadness.html#afcde52e430e0a853237e4938b27ca771">transform()</a> </p>
<p>Both dimensions of <code>c</code> must be the same and match all dimensions of the input tensor <code>t</code>. All tensors must be contiguous.</p>
<p>Performs the same operation as <code>transform</code> but it requires that the caller pass in workspace and a preallocated result, hoping that that both can be reused. If the result and workspace are reused between calls, then no tensor constructors need be called and cache locality should be improved. By passing in the workspace, this routine is kept thread safe.</p>
<p>The input, result and workspace tensors must be distinct.</p>
<p>All input tensors must be contiguous and fastest execution will result if all dimensions are even and data is aligned on 16-byte boundaries. The workspace and the result must be of the same size as the input <code>t</code> . The result tensor need not be initialized before calling fast_transform.</p>
<div class="fragment"><div class="line">result(i,j,k,...) &lt;-- <a class="code" href="namespacempfr.html#a87743f7473a7cdc1461428ed9f9b3565">sum</a>(i<span class="stringliteral">&#39;,j&#39;</span>, k<span class="stringliteral">&#39;,...) t(i&#39;</span>,j<span class="stringliteral">&#39;,k&#39;</span>,...)  c(i&#39;,i) c(j&#39;,j) c(k&#39;,k) ...</div>
</div><!-- fragment --><p>The input dimensions of <code>t</code> must all be the same . </p>

<p>References <a class="el" href="tensor_8h.html#a0fac5864e00584bf98923b4c2dc497f9">IS_ODD</a>, <a class="el" href="tensor_8h.html#af5ac0e99ffc1512df430abf057a5ddda">IS_UNALIGNED</a>, <a class="el" href="mxm_8h.html#a219c8b0351b5739143e9a0941444fbe0">mTxm()</a>, <a class="el" href="namespacemadness.html#a8e7be5d33f788dce0d7e042409d96146">madness::mTxmq()</a>, <a class="el" href="namespacemadness.html#a6dc961e990acc3f06e6dd3021a6bf100">madness::mTxmq_padding()</a>, <a class="el" href="namespacestd.html#ad33a269e67f055aaa18f57f76b015387">std::swap()</a>, and <a class="el" href="namespacemadness.html#aa3c1e8da44c36b8f3cbf1cef1f5bcb9f">madness::TENSOR_RESULT_TYPE()</a>.</p>

<p>Referenced by <a class="el" href="singletonmadness_1_1FunctionImpl.html#ae16ac90cb04ac7e605aece36749ec83c">madness::FunctionImpl&lt; Q, NDIM &gt;::err_box()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a3536d04963d17532276902ac8c69ca22">madness::FunctionImpl&lt; T, NDIM &gt;::filter()</a>, <a class="el" href="miketest_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a2b01b900fc83d75c39aedf83a92ad171">madness::FunctionImpl&lt; T, NDIM &gt;::project()</a>, <a class="el" href="oldtest_8cc.html#aa5bcb1e3b339e2bb6742c65162376c59">Test7()</a>, <a class="el" href="group__tensor.html#ga3d20c4bd2d94810775fbdf801ee7eeac">madness::transform()</a>, and <a class="el" href="singletonmadness_1_1FunctionImpl.html#a6833892559d50719da74bd768a40ef0d">madness::FunctionImpl&lt; T, NDIM &gt;::unfilter()</a>.</p>

</div>
</div>
<a class="anchor" id="ga15d1a8d4059cb71a3028e3e5e548ab2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Q &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt;<a class="el" href="type__data_8h.html#ad89485f5bdd3c92f606c723d4d392cb0">TENSOR_RESULT_TYPE</a>(T,Q)&gt; madness::general_transform </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; Q &gt;&#160;</td>
          <td class="paramname"><em>c</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform all dimensions of the tensor t by distinct matrices c. </p>
<p>Similar to transform but each dimension is transformed with a distinct matrix. </p><div class="fragment"><div class="line">result(i,j,k...) &lt;-- <a class="code" href="namespacempfr.html#a87743f7473a7cdc1461428ed9f9b3565">sum</a>(i<span class="stringliteral">&#39;,j&#39;</span>, k<span class="stringliteral">&#39;,...) t(i&#39;</span>,j<span class="stringliteral">&#39;,k&#39;</span>,...) c[0](i&#39;,i) c[1](j&#39;,j) c[2](k&#39;,k) ...</div>
</div><!-- fragment --><p> The first dimension of the matrices c must match the corresponding dimension of t. </p>

<p>References <a class="el" href="namespacemadness.html#a3ada99467c155aee7254c28cadb138fe">madness::inner()</a>, and <a class="el" href="namespacemadness.html#aa3c1e8da44c36b8f3cbf1cef1f5bcb9f">madness::TENSOR_RESULT_TYPE()</a>.</p>

</div>
</div>
<a class="anchor" id="gada3ed3011f4c87354995910e2632a6ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt; typename Tensor&lt;T&gt;::scalar_type &gt; madness::imag </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new tensor holding the imaginary part of each element of t (complex types only) </p>

<p>References <a class="el" href="tensor__macros_8h.html#ab4e453e4edbb844ab3ef9e4cb96e46d3">BINARY_OPTIMIZED_ITERATOR</a>.</p>

</div>
</div>
<a class="anchor" id="gac7141b1a1d6a655cfcb159dff23debdf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Q &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt;<a class="el" href="type__data_8h.html#ad89485f5bdd3c92f606c723d4d392cb0">TENSOR_RESULT_TYPE</a>(T,Q)&gt; madness::inner </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; Q &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k0</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k1</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inner product ... result(i,j,...,p,q,...) = sum(z) left(i,j,...,z)*right(z,p,q,...) </p>
<p>By default it contracts the last dimension of the left tensor and the first dimension of the right tensor. These defaults can be changed by specifying <code>k0</code> and <code>k1</code> , the index to contract in the left and right side tensors, respectively. The defaults correspond to (<code>k0=-1</code> and <code>k1=0</code> ). </p>

<p>References <a class="el" href="group__tensor.html#ga840d462d1f6f9b2f42ff7ff131323395">madness::inner_result()</a>, <a class="el" href="tensorexcept_8h.html#a2d3bb3646d0996a33f0161d3f67d85f9">TENSOR_ASSERT</a>, and <a class="el" href="tensor__macros_8h.html#af1a0f280b8ae36699bdcbe66c65a2f5c">TENSOR_MAXDIM</a>.</p>

</div>
</div>
<a class="anchor" id="ga840d462d1f6f9b2f42ff7ff131323395"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Q &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void madness::inner_result </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; Q &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor&lt; <a class="el" href="type__data_8h.html#ad89485f5bdd3c92f606c723d4d392cb0">TENSOR_RESULT_TYPE</a>(T, Q) &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accumulate inner product into user provided, contiguous, correctly sized result tensor. </p>
<p>This routine may be used to optimize away the tensor constructor of the result tensor in inner loops when the result tensor may be reused or accumulated into. If the user calls this routine directly very little checking is done since it is intended as an optimization for small tensors. As far as the result goes, the caller is completely responsible for providing a contiguous tensor that has the correct dimensions and is appropriately initialized. The inner product is accumulated into result. </p>

<p>References <a class="el" href="classmadness_1_1TensorIterator.html#af0ba3570325e0d1a892e5a7ddcc66a74">madness::TensorIterator&lt; T, Q, R &gt;::_p0</a>, <a class="el" href="classmadness_1_1TensorIterator.html#a85e99a4bd76a6f9cc19877172c3d6c55">madness::TensorIterator&lt; T, Q, R &gt;::_s0</a>, <a class="el" href="mxm_8h.html#a219c8b0351b5739143e9a0941444fbe0">mTxm()</a>, <a class="el" href="mxm_8h.html#afba63a290df5999dc2b65fe7248b3140">mTxmT()</a>, <a class="el" href="mxm_8h.html#a74f284edf7b73dbfbd7caf76cff47175">mxm()</a>, <a class="el" href="mxm_8h.html#a53c3e3f1bb411aa7ba26c46005423d91">mxmT()</a>, <a class="el" href="classmadness_1_1TensorIterator.html#ac80acef10f4f59f5e679ea799319b4ae">madness::TensorIterator&lt; T, Q, R &gt;::reset()</a>, <a class="el" href="config_8h.html#a080abdcb9c02438f1cd2bb707af25af8">restrict</a>, <a class="el" href="namespacempfr.html#a87743f7473a7cdc1461428ed9f9b3565">mpfr::sum()</a>, and <a class="el" href="namespacemadness.html#aa3c1e8da44c36b8f3cbf1cef1f5bcb9f">madness::TENSOR_RESULT_TYPE()</a>.</p>

<p>Referenced by <a class="el" href="group__tensor.html#gac7141b1a1d6a655cfcb159dff23debdf">madness::inner()</a>, and <a class="el" href="namespacemadness.html#a9a1932bae5db79b0e070edae8e1e4695">madness::ortho5()</a>.</p>

</div>
</div>
<a class="anchor" id="ga60dc017e21558ad38f77997514ada97e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Q &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IsSupported&lt; TensorTypeData&lt;Q&gt;, Tensor&lt;T&gt; &gt;::type madness::operator* </td>
          <td>(</td>
          <td class="paramtype">const Q &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The class defines tensor op scalar ... here define scalar op tensor. </p>

</div>
</div>
<a class="anchor" id="ga50c2930438aa659d6381f667951c69da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Q &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IsSupported&lt; TensorTypeData&lt;Q&gt;, Tensor&lt;T&gt; &gt;::type madness::operator+ </td>
          <td>(</td>
          <td class="paramtype">Q&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The class defines tensor op scalar ... here define scalar op tensor. </p>

</div>
</div>
<a class="anchor" id="gad4207f3974c2c7b2090334147b7582d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Q &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IsSupported&lt; TensorTypeData&lt;Q&gt;, Tensor&lt;T&gt; &gt;::type madness::operator- </td>
          <td>(</td>
          <td class="paramtype">Q&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The class defines tensor op scalar ... here define scalar op tensor. </p>

</div>
</div>
<a class="anchor" id="ga188a6d50fd0ad90404e7f31b06ea4a9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; madness::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print (for human consumption) a tensor to the stream. </p>

</div>
</div>
<a class="anchor" id="ga819bde0edb797aaf642184f9d461edca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GenTensor&lt;T&gt; madness::outer </td>
          <td>(</td>
          <td class="paramtype">const GenTensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GenTensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outer product ... result(i,j,...,p,q,...) = left(i,k,...)*right(p,q,...) </p>

<p>Referenced by <a class="el" href="structmadness_1_1FunctionImpl_1_1Vphi__op__NS.html#a1bdac520f333d7718e17bf51a2818cc3">madness::FunctionImpl&lt; T, NDIM &gt;::Vphi_op_NS&lt; opT, LDIM &gt;::make_childrens_sum_coeffs()</a>, <a class="el" href="classmadness_1_1TwoElectronInterface.html#a824f228eeb4746fdc2e25ea58dc8b9b4">madness::TwoElectronInterface&lt; double, 6 &gt;::make_coeff()</a>, <a class="el" href="structmadness_1_1FunctionImpl_1_1Vphi__op__NS.html#aa5724427dc17729952f5a2895923cc41">madness::FunctionImpl&lt; T, NDIM &gt;::Vphi_op_NS&lt; opT, LDIM &gt;::make_sum_coeffs()</a>, <a class="el" href="structmadness_1_1FunctionImpl_1_1hartree__op.html#a70a2320cb69d33778931b5897c00e1b6">madness::FunctionImpl&lt; T, NDIM &gt;::hartree_op&lt; LDIM, leaf_opT &gt;::operator()()</a>, <a class="el" href="namespacemadness.html#a9a1932bae5db79b0e070edae8e1e4695">madness::ortho5()</a>, <a class="el" href="group__tensor.html#ga32104e2daa59a9df556bba500e24fa8e">madness::outer_low_rank()</a>, and <a class="el" href="oldtest_8cc.html#aa5bcb1e3b339e2bb6742c65162376c59">Test7()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3c36eca58b8a5c593b0443d0f8ec63aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt;T&gt; madness::outer </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outer product ... result(i,j,...,p,q,...) = left(i,k,...)*right(p,q,...) </p>

<p>References <a class="el" href="classmadness_1_1TensorIterator.html#af0ba3570325e0d1a892e5a7ddcc66a74">madness::TensorIterator&lt; T, Q, R &gt;::_p0</a>, <a class="el" href="classmadness_1_1TensorIterator.html#a85e99a4bd76a6f9cc19877172c3d6c55">madness::TensorIterator&lt; T, Q, R &gt;::_s0</a>, <a class="el" href="classmadness_1_1TensorIterator.html#a7592ee3127ef9bf3667124f84bf65bd4">madness::TensorIterator&lt; T, Q, R &gt;::dimj</a>, <a class="el" href="classmadness_1_1TensorIterator.html#ac80acef10f4f59f5e679ea799319b4ae">madness::TensorIterator&lt; T, Q, R &gt;::reset()</a>, <a class="el" href="tensorexcept_8h.html#a2d3bb3646d0996a33f0161d3f67d85f9">TENSOR_ASSERT</a>, and <a class="el" href="tensor__macros_8h.html#af1a0f280b8ae36699bdcbe66c65a2f5c">TENSOR_MAXDIM</a>.</p>

</div>
</div>
<a class="anchor" id="ga32104e2daa59a9df556bba500e24fa8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GenTensor&lt;T&gt; madness::outer_low_rank </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outer product ... result(i,j,...,p,q,...) = left(i,k,...)*right(p,q,...) </p>

<p>References <a class="el" href="group__tensor.html#ga819bde0edb797aaf642184f9d461edca">madness::outer()</a>.</p>

<p>Referenced by <a class="el" href="structmadness_1_1FunctionImpl_1_1recursive__apply__op.html#ab50e3bca4a555027b9b66f003494ae26">madness::FunctionImpl&lt; T, NDIM &gt;::recursive_apply_op&lt; opT, LDIM &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="ga569b463a16f2617e188e37ea8cb78279"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt; typename Tensor&lt;T&gt;::scalar_type &gt; madness::real </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new tensor holding the real part of each element of t (complex types only) </p>

<p>References <a class="el" href="tensor__macros_8h.html#ab4e453e4edbb844ab3ef9e4cb96e46d3">BINARY_OPTIMIZED_ITERATOR</a>.</p>

</div>
</div>
<a class="anchor" id="gad15fdd7b42d8efddf8a24f7d7f8d4130"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Q , class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmadness_1_1TensorIterator.html">madness::TensorIterator</a>&lt; T, Q, <a class="el" href="svpe_8cc.html#a0877420f3d7b1f47b871d2ccb47168d8">R</a> &gt;::TensorIterator </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; Q &gt; *&#160;</td>
          <td class="paramname"><em>t1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; <a class="el" href="svpe_8cc.html#a0877420f3d7b1f47b871d2ccb47168d8">R</a> &gt; *&#160;</td>
          <td class="paramname"><em>t2</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>iterlevel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimize</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fusedim</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>jdim</em> = <code>default_jdim</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for general iterator to compose operations over up to three tensors. </p>
<p>Macros have been defined in <code><a class="el" href="tensor__macros_8h.html" title="Macros for easy and efficient iteration over tensors. ">tensor_macros.h</a></code> to take the pain out of using iterators. The options have the following effects</p><ul>
<li><code>optimize</code> reorders dimensions for optimal strides (only applies if iterlevel=1). If jdim==default_jdim, all dimensions are reordered for optimal stride. If jdim is not the default value, then dimension jdim is excluded from the set of dimensions being optimized.</li>
<li><code>fusedim</code> concatenates contiguous dimensions into the inner loop (only applies if iterlevel=1 and jdim=default_jdim).</li>
<li><code>iterlevel</code> can have two values 0=elementwise, 1=vectorwise. Elementwise implies that the iterator returns successive elements, and explicitly in the expected order for the tensor (i.e., with the last index varying fastest). Vectorwise implies that the user is responsible for iterating over dimension jdim.</li>
<li>jdim &mdash; if iterlevel=1, then jdim determines which dimension is left for iteration with an explicit for loop. Negative values implies jdim+=ndim following the convention of <a class="el" href="classmadness_1_1Slice.html" title="A slice defines a sub-range or patch of a dimension. ">Slice</a> (and Python). If (optimize) the default is the fastest varying dimension. If (!optimize) the default is the last dimension (jdim=-1). If (fusedim) contiguous dimensions are fused into this inner loop. Specifying a non-default value for jdim disables fusedim and restricts optimization to reordering only the exterior loops (so that the loop the user is iterating over corresponds exactly to those in dimension jdim).</li>
</ul>
<dl class="section user"><dt>During iteration:</dt><dd></dd></dl>
<ul>
<li><code>ind</code>[] will contain the current iteration indices .. BUT if <code>optimize=true</code> , they will not necessarily be in the order of those of the tensor. if fusedim is true, then there may be fewer dimensions than the input tensor.</li>
<li><code>_p0</code>, <code>_p1</code>, <code>_p2</code> will point to the current elements of <code>t0</code>,t1,t2 noting that if <code>iterlevel&gt;0</code>, the user must provide additional <code>for</code> loops to iterate over the additional dimensions</li>
<li><code>stride0</code>[], <code>stride1</code>[], <code>stride2</code>[] will contain the strides for each (possibly reordered) dimension. If <code>iterlevel=1</code>, <code>_s0</code>,_s1,s2 contain the stride info for the dimension that the user is responsible for iterating over.</li>
<li><code>dimj</code> -&gt; the size of the j'th dimension </li>
</ul>

<p>References <a class="el" href="namespacempfr.html#a9b1c071643a547884db48dcf8745ec78">mpfr::dim()</a>, <a class="el" href="dielectric_8cc.html#a0877420f3d7b1f47b871d2ccb47168d8">R</a>, <a class="el" href="namespacestd.html#ad33a269e67f055aaa18f57f76b015387">std::swap()</a>, <a class="el" href="namespacestd_1_1tr1.html#a997603b2d09924bf040b5dcd9eac7f7b">std::tr1::T()</a>, <a class="el" href="tensorexcept_8h.html#a2d3bb3646d0996a33f0161d3f67d85f9">TENSOR_ASSERT</a>, and <a class="el" href="tensor__macros_8h.html#af1a0f280b8ae36699bdcbe66c65a2f5c">TENSOR_MAXDIM</a>.</p>

</div>
</div>
<a class="anchor" id="ga3d20c4bd2d94810775fbdf801ee7eeac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Q &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt;<a class="el" href="type__data_8h.html#ad89485f5bdd3c92f606c723d4d392cb0">TENSOR_RESULT_TYPE</a>(T,Q)&gt; madness::transform </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; Q &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform all dimensions of the tensor t by the matrix c. </p>
<p>Often used to transform all dimensions from one basis to another </p><div class="fragment"><div class="line">result(i,j,k...) &lt;-- <a class="code" href="namespacempfr.html#a87743f7473a7cdc1461428ed9f9b3565">sum</a>(i<span class="stringliteral">&#39;,j&#39;</span>, k<span class="stringliteral">&#39;,...) t(i&#39;</span>,j<span class="stringliteral">&#39;,k&#39;</span>,...) c(i&#39;,i) c(j&#39;,j) c(k&#39;,k) ...</div>
</div><!-- fragment --><p> The input dimensions of <code>t</code> must all be the same and agree with the first dimension of <code>c</code> . The dimensions of <code>c</code> may differ in size. If the dimensions of <code>c</code> are the same, and the operation is being performed repeatedly, then you might consider calling <code>fast_transform</code> instead which enables additional optimizations and can eliminate all constructor overhead and improve cache locality. </p>

<p>References <a class="el" href="gfit_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>, <a class="el" href="group__tensor.html#ga7d9a64acdea379a5d7df62b88c25ee97">madness::fast_transform()</a>, <a class="el" href="namespacemadness.html#a3ada99467c155aee7254c28cadb138fe">madness::inner()</a>, <a class="el" href="tensorexcept_8h.html#a2d3bb3646d0996a33f0161d3f67d85f9">TENSOR_ASSERT</a>, and <a class="el" href="namespacemadness.html#aa3c1e8da44c36b8f3cbf1cef1f5bcb9f">madness::TENSOR_RESULT_TYPE()</a>.</p>

</div>
</div>
<a class="anchor" id="gacab686d57a7139600308698eb2b4abf6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Q &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt;<a class="el" href="type__data_8h.html#ad89485f5bdd3c92f606c723d4d392cb0">TENSOR_RESULT_TYPE</a>(T,Q)&gt; madness::transform_dir </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; Q &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms one dimension of the tensor t by the matrix c, returns new contiguous tensor. </p>
<div class="fragment"><div class="line"><a class="code" href="group__tensor.html#gacab686d57a7139600308698eb2b4abf6">transform_dir</a>(t,c,1) = r(i,j,k,...) = <a class="code" href="namespacempfr.html#a87743f7473a7cdc1461428ed9f9b3565">sum</a>(j<span class="stringliteral">&#39;) t(i,j&#39;</span>,k,...) * <a class="code" href="gfit_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>(j<span class="stringliteral">&#39;,j)</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Tensor to transform (size of dimension to be transformed must match size of first dimension of <code>c</code> ) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Matrix used for the transformation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>Dimension (or axis) to be transformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a new, contiguous tensor </dd></dl>

<p>References <a class="el" href="namespacemadness.html#a51a0751f3bf95a504c43be228e01b7c2">madness::copy()</a>, and <a class="el" href="namespacemadness.html#a3ada99467c155aee7254c28cadb138fe">madness::inner()</a>.</p>

<p>Referenced by <a class="el" href="singletonmadness_1_1FunctionImpl.html#a2aeed89dbbd2294662dbcbd834cc7381">madness::FunctionImpl&lt; Q, NDIM &gt;::apply_1d_realspace_push_op()</a>.</p>

</div>
</div>
<a class="anchor" id="gae674b4cfcc0781d9a5319a1dbefd868b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt;T&gt; madness::transpose </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new deep copy of the transpose of the input tensor. </p>

<p>References <a class="el" href="namespacemadness.html#a51a0751f3bf95a504c43be228e01b7c2">madness::copy()</a>, and <a class="el" href="tensorexcept_8h.html#a2d3bb3646d0996a33f0161d3f67d85f9">TENSOR_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="classmadness_1_1FunctionCommonData.html#abb2efbc619c367a103755c2874c1e522">madness::FunctionCommonData&lt; T, NDIM &gt;::_init_quadrature()</a>, <a class="el" href="classmadness_1_1SCF.html#a4dfca1a3dd457b4143a856c741c74538">madness::SCF::analyze_vectors()</a>, <a class="el" href="classmadness_1_1Convolution1D.html#a02cfad55bc9889cd06b81349e48e7ddb">madness::Convolution1D&lt; Q &gt;::Convolution1D()</a>, <a class="el" href="structSCF.html#a8822af7eebd75788e870bafa2c644397">SCF::diag_fock_matrix()</a>, <a class="el" href="DFcode_2distpm_8cc.html#a147e74779c6669346bc7f7a49d755931">distributed_localize_PM()</a>, <a class="el" href="group__linalg.html#ga77bb5f0d7489b133019bf5f1a7a99368">madness::gelss()</a>, <a class="el" href="namespacemadness.html#ab84ddf81ee3ef0a5e57025c8e7e510de">madness::geqp3()</a>, <a class="el" href="group__linalg.html#ga865ca226164574b67f1f7ff6fe75eef5">madness::gesv()</a>, <a class="el" href="classmadness_1_1SCF.html#a8dac9c3b11ccdc137933d6bd083c8439">madness::SCF::get_fock_transformation()</a>, <a class="el" href="classmadness_1_1SCF.html#a7b0245d91603219289879b739086552e">madness::SCF::initial_guess()</a>, <a class="el" href="structSCF.html#a592f896df312705332e1be6dcaf5d63b">SCF::localize_boys()</a>, <a class="el" href="eigen__solver_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, <a class="el" href="structSCF.html#a3847263be8d48f72e993d778e072b2f3">SCF::make_fock_matrix()</a>, <a class="el" href="classmadness_1_1SCF.html#af847d591ae86a982ba80eb7449c6303c">madness::SCF::make_fock_matrix()</a>, <a class="el" href="namespacemadness.html#aa3bcfd954edff449924baed80c3d52ed">madness::my_conj_transpose()</a>, <a class="el" href="namespacemadness.html#a8fba2801777de78243dd75f8d2ff7fb6">madness::orgqr()</a>, <a class="el" href="namespacemadness.html#a9a1932bae5db79b0e070edae8e1e4695">madness::ortho5()</a>, <a class="el" href="namespacemadness.html#a3e8d35463d9f6ef8f32075b87a27aebd">madness::qr()</a>, <a class="el" href="classmadness_1_1Convolution1D.html#ab197bfd5ff99d4936c46b7a453ceb791">madness::Convolution1D&lt; Q &gt;::rnlij()</a>, <a class="el" href="group__linalg.html#gafa1040ea790164d2920d41e9b4ec3fc2">madness::syev()</a>, <a class="el" href="group__linalg.html#ga27afd954228a021066ae01a3ac38f7d2">madness::sygv()</a>, <a class="el" href="namespacemadness.html#a5f87fb9811af0453ed7bfce489a3441a">madness::test_syev()</a>, and <a class="el" href="namespacemadness.html#afcde52e430e0a853237e4938b27ca771">madness::transform()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 26 2014 10:39:31 for MADNESS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
