<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>MADNESS: Serialization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MADNESS
   &#160;<span id="projectnumber">version 0.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Serialization<div class="ingroups"><a class="el" href="group__libraries.html">MADNESS libraries</a> &raquo; <a class="el" href="group__parallel__runtime.html">Parallel programming environment</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Serialization:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__serialization.png" border="0" alt="" usemap="#group____serialization"/>
<map name="group____serialization" id="group____serialization">
<area shape="rect" id="node1" href="group__parallel__runtime.html" title="Parallel programming\l environment" alt="" coords="5,5,166,49"/></map>
</td></tr></table></center>
</div>
<p>The programmer should not need to include <a class="el" href="archive_8h.html" title="Interface templates for the archives (serialization) ">world/archive.h</a> directly. Instead, include the header file for the actual archive (binary file, text/xml file, vector in memory, ...) that you want to use.</p>
<dl class="section user"><dt>Background</dt><dd></dd></dl>
<p>The interface and implementation are deliberately modelled, albeit loosely, upon the Boost serialization class (thanks boost!). The major differences are that this archive class does <em>not</em> break cycles and does <em>not</em> automatically store unique copies of data referenced by multiple objects. Also, classes are responsbible for managing their own version information. At the lowest level, the interface to an archive also differs to facilitate vectorization and high-bandwidth data transfer. The implementation employs templates that are almost entirely inlined. This should enable low-overhead use of archives in applications such as interprocess communication.</p>
<dl class="section user"><dt>How to use an archive?</dt><dd></dd></dl>
<p>An archive is a uni-directional stream of typed data to/from disk, memory, or another process. Whether the stream is for input or for output, you can use the <code>&amp;</code> operator to transfer data to/from the stream. If you really want, you can also use the <code>&lt;&lt;</code> and <code>&gt;&gt;</code> for output or input, respectively, but there is no reason to do so. The <code>&amp;</code> operator chains just like <code>&lt;&lt;</code> for <code>cout</code> or <code>&gt;&gt;</code> for <code>cin</code>. You may discover in <code><a class="el" href="archive_8h.html" title="Interface templates for the archives (serialization) ">archive.h</a></code> other interfaces but you should <em>not</em> use them &mdash; use the &amp; operator! The lower level interfaces will probably not, or only inconsistently incorpoate type information and may even appear to work when they are not.</p>
<p>Unless type checking has not been implemented by an archive for reasons of efficiency (e.g., message passing) a C-string exception will be thrown on a type-mismatch when deserializing. End-of-file, out-of-memory and other others also generate string exceptions.</p>
<p>Fundamental types (see below), STL complex, vector, strings, pairs and maps, and tensors (int, long, float, double, float_complex, double_complex) all just work without you doing anything, as do fixed dimension arrays of the same (STL allocators are not presently accomodated). E.g., </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> finished=<span class="keyword">false</span>;</div>
<div class="line"><span class="keywordtype">int</span> info[3] = {1,33,2};</div>
<div class="line">map&lt;int,double&gt; <a class="code" href="tdse4_8cc.html#ac63c8aae13d788421ccbc301126510c2">fred</a>;</div>
<div class="line">map[0]=55.0; map[1]=99.0;</div>
<div class="line">BinaryFstreamOutputArchive ar(<span class="stringliteral">&#39;restart.dat&#39;</span>);</div>
<div class="line">ar &amp; map &amp; info &amp; finished;</div>
</div><!-- fragment --><p> Deserializing is identical, except that you need to use an input archive, c.f., </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> finished;</div>
<div class="line"><span class="keywordtype">int</span> info[3];</div>
<div class="line">map&lt;int,double&gt; <a class="code" href="tdse4_8cc.html#ac63c8aae13d788421ccbc301126510c2">fred</a>;</div>
<div class="line">BinaryFstreamInputArchive ar(<span class="stringliteral">&#39;restart.dat&#39;</span>);</div>
<div class="line">ar &amp; map &amp; info &amp; finished;</div>
</div><!-- fragment --><p>Variable dimension and dynamically allocated arrays do not have their dimension encoded in their type. The best way to (de)serialize them is to wrap them in an <code>archive_array</code> as follows. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>[n]; <span class="comment">// n is not known at compile time</span></div>
<div class="line"><span class="keywordtype">double</span> *p = <span class="keyword">new</span> <span class="keywordtype">double</span>[n];</div>
<div class="line">ar &amp; <a class="code" href="namespacemadness_1_1archive.html#a81d3778e719b3e2deed3afec2efb07a5">wrap</a>(<a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>,n) &amp; <a class="code" href="namespacemadness_1_1archive.html#a81d3778e719b3e2deed3afec2efb07a5">wrap</a>(p,n);</div>
</div><!-- fragment --><p> The <code><a class="el" href="namespacemadness_1_1archive.html#a81d3778e719b3e2deed3afec2efb07a5" title="Factory function to wrap dynamically allocated pointer as typed archive_array. ">wrap()</a></code> function template is a factory function to simplify instantiation of a correctly typed <code>archive_array</code> template. Note that when deserializing you must have first allocated the array &mdash; the above code can be used for both serializing and deserializing. If you want the memory to be automatically allocated consider using either an STL vector or a madness tensor.</p>
<p>To transfer the actual value of a pointer to a stream (is this really what you want?) then store an archive_ptr wrapping it. The factor function <a class="el" href="namespacemadness_1_1archive.html#a7ef7f1595a8d871e5c2db488a6e89fb2">wrap_ptr()</a> assists in doing this, e.g., here for a function pointer </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> foo();</div>
<div class="line">ar &amp; <a class="code" href="namespacemadness_1_1archive.html#a7ef7f1595a8d871e5c2db488a6e89fb2">wrap_ptr</a>(foo);</div>
</div><!-- fragment --><dl class="section user"><dt>User-defined types</dt><dd></dd></dl>
<p>User-defined types require a little more effort. Three cases are distinguished.</p><ul>
<li>symmetric load and store<ul>
<li>intrusive</li>
<li>non-intrusive</li>
</ul>
</li>
<li>non-symmetric load and store</li>
</ul>
<p>We will examine each in turn, but we first need to discuss a little about the implementation.</p>
<p>When transfering an object <code>obj</code> to/from an archive <code>ar</code> with <code>ar&amp;obj</code>, you are invoking the templated function </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive, <span class="keyword">class</span> T&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">const</span> Archive&amp; <a class="code" href="namespacemadness_1_1archive.html#a4b6ea55303f7685299d5e69e872f0b9c">operator&amp;</a>(<span class="keyword">const</span> Archive&amp; ar, <a class="code" href="namespacestd_1_1tr1.html#a997603b2d09924bf040b5dcd9eac7f7b">T</a>&amp; obj);</div>
</div><!-- fragment --><p> that then invokes other templated functions to redirect to input or output streams as appropriate, manage type checking, etc.. We would now like to overload the behaviour of these functions in order accomodate your fancy object. However, function templates cannot be partially specialized. Following the technique recommended <a href="http://www.gotw.ca/publications/mill17.htm">here</a> (look for moral#2), each of the templated functions directly calls a member of a templated class. Classes, unlike functions, can be partially specialized so it is easy to control and predict what is happening. Thus, in order to change the behaviour of all archives for an object you just have to provide a partial specialization of the appropriate class(es). Do <em>not</em> overload any of the function templates.</p>
<p><em>Symmetric intrusive method</em></p>
<p>Many classes can use the same code for serializing and deserializing. If such a class can be modified, the cleanest way of enabling serialization is to add a templated method as follows. </p><div class="fragment"><div class="line"><span class="keyword">class </span>A {</div>
<div class="line">    <span class="keywordtype">float</span> <a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    A(<span class="keywordtype">float</span> a = 0.0) : a(a) {}</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacemadness_1_1archive.html#a4cafbcc10d5dab6734b6e60fa9142501">serialize</a>(<span class="keyword">const</span> Archive&amp; ar) {ar &amp; <a class="code" href="y1_8cc.html#a55807b620385f9c5feb4bb25a651e8df">a</a>;}</div>
<div class="line">};</div>
</div><!-- fragment --><p><em>Symmetric non-intrusive method</em></p>
<p>If a class with symmetric serialization cannot be modified, then you can define an external class template with the following signature in the <code><a class="el" href="namespacemadness_1_1archive.html">madness::archive</a></code> namespace (where <code>Obj</code> is the name of your type). </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacemadness.html">madness</a> {</div>
<div class="line">    <span class="keyword">namespace </span>archive {</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line">        <span class="keyword">struct </span>ArchiveSerializeImpl&lt;Archive,Obj&gt; {</div>
<div class="line">            <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="structmadness_1_1archive_1_1ArchiveSerializeImpl.html#a89d641fc2da86019983392816f448584">serialize</a>(<span class="keyword">const</span> Archive&amp; ar, Obj&amp; obj);</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>For example, </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="tdse1d_8cc.html#a9491de326f16c5cce8c064fb5098a07b">B</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="y1_8cc.html#a8edb09333aecbc60d69c0ce58542e31d">b</a>;</div>
<div class="line">    <a class="code" href="tdse1d_8cc.html#a9491de326f16c5cce8c064fb5098a07b">B</a>(<span class="keywordtype">bool</span> b = <span class="keyword">false</span>) : b(b) {};</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacemadness.html">madness</a> {</div>
<div class="line">    <span class="keyword">namespace </span>archive {</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line">        <span class="keyword">struct </span>ArchiveSerializeImpl&lt;Archive,<a class="code" href="tdse1d_8cc.html#a9491de326f16c5cce8c064fb5098a07b">B</a>&gt; {</div>
<div class="line">            <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="structmadness_1_1archive_1_1ArchiveSerializeImpl.html#a89d641fc2da86019983392816f448584">serialize</a>(<span class="keyword">const</span> Archive&amp; ar, <a class="code" href="tdse1d_8cc.html#a9491de326f16c5cce8c064fb5098a07b">B</a>&amp; <a class="code" href="y1_8cc.html#a8edb09333aecbc60d69c0ce58542e31d">b</a>) {ar &amp; b.b;};</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><em>Non-symmetric non-intrusive</em></p>
<p>For classes that do not have symmetric (de)serialization you must define separate partial templates for the functions <code>load</code> and <code>store</code> with these signatures and again in the <code><a class="el" href="namespacemadness_1_1archive.html">madness::archive</a></code> namespace. </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacemadness.html">madness</a> {</div>
<div class="line">    <span class="keyword">namespace </span>archive {</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line">        <span class="keyword">struct </span>ArchiveLoadImpl&lt;Archive,Obj&gt; {</div>
<div class="line">            <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="structmadness_1_1archive_1_1ArchiveLoadImpl.html#ae3fde4dc6adb014d0e7fc12c56ba14a7">load</a>(<span class="keyword">const</span> Archive&amp; ar, Obj&amp; obj);</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line">        <span class="keyword">struct </span>ArchiveStoreImpl&lt;Archive,Obj&gt; {</div>
<div class="line">            <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="structmadness_1_1archive_1_1ArchiveStoreImpl.html#adeb884410504421544b13943779a96d4">store</a>(<span class="keyword">const</span> Archive&amp; ar, Obj&amp; obj);</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>First a simple, but artificial example. </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="mtxm__gen_8h.html#aaeb113699ebccfb29980ae43d2e19bdd">C</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">long</span> <a class="code" href="gfit_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>;</div>
<div class="line">    <a class="code" href="mtxm__gen_8h.html#aaeb113699ebccfb29980ae43d2e19bdd">C</a>(<span class="keywordtype">long</span> c = 0) : c(c) {};</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacemadness.html">madness</a> {</div>
<div class="line">    <span class="keyword">namespace </span>archive {</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line">        <span class="keyword">struct </span>ArchiveLoadImpl&lt;Archive,<a class="code" href="mtxm__gen_8h.html#aaeb113699ebccfb29980ae43d2e19bdd">C</a>&gt; {</div>
<div class="line">            <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="structmadness_1_1archive_1_1ArchiveLoadImpl.html#ae3fde4dc6adb014d0e7fc12c56ba14a7">load</a>(<span class="keyword">const</span> Archive&amp; ar, <a class="code" href="mtxm__gen_8h.html#aaeb113699ebccfb29980ae43d2e19bdd">C</a>&amp; <a class="code" href="gfit_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>) {ar &amp; c.c;}</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line">        <span class="keyword">struct </span>ArchiveStoreImpl&lt;Archive,<a class="code" href="mtxm__gen_8h.html#aaeb113699ebccfb29980ae43d2e19bdd">C</a>&gt; {</div>
<div class="line">            <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="structmadness_1_1archive_1_1ArchiveStoreImpl.html#adeb884410504421544b13943779a96d4">store</a>(<span class="keyword">const</span> Archive&amp; ar, <span class="keyword">const</span> <a class="code" href="mtxm__gen_8h.html#aaeb113699ebccfb29980ae43d2e19bdd">C</a>&amp; <a class="code" href="gfit_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>) {ar &amp; c.c;}</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now a more complicated example that genuinely requires asymmetric load and store. First, a class definition for a simple linked list. </p><div class="fragment"><div class="line"><span class="keyword">class </span>linked_list {</div>
<div class="line">    <span class="keywordtype">int</span> value;</div>
<div class="line">    linked_list *next;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    linked_list(<span class="keywordtype">int</span> value = 0) : value(value), next(0) {};</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> append(<span class="keywordtype">int</span> value) {</div>
<div class="line">        <span class="keywordflow">if</span> (next) next-&gt;append(value);</div>
<div class="line">        <span class="keywordflow">else</span> next = <span class="keyword">new</span> linked_list(value);</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> set_value(<span class="keywordtype">int</span> val) {value = val;};</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> get_value()<span class="keyword"> const </span>{<span class="keywordflow">return</span> value;};</div>
<div class="line"></div>
<div class="line">    linked_list* get_next()<span class="keyword"> const </span>{<span class="keywordflow">return</span> next;};</div>
<div class="line">};</div>
</div><!-- fragment --><p> And this is how you (de)serialize it. </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacemadness.html">madness</a> {</div>
<div class="line">    <span class="keyword">namespace </span>archive {</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line">        <span class="keyword">struct </span>ArchiveStoreImpl&lt;Archive,linked_list&gt; {</div>
<div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structmadness_1_1archive_1_1ArchiveStoreImpl.html#adeb884410504421544b13943779a96d4">store</a>(<span class="keyword">const</span> Archive&amp; ar, <span class="keyword">const</span> linked_list&amp; <a class="code" href="gfit_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>) {</div>
<div class="line">          ar &amp; c.get_value() &amp; bool(c.get_next());</div>
<div class="line">          <span class="keywordflow">if</span> (c.get_next()) ar &amp; *c.get_next();</div>
<div class="line">            };</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line">        <span class="keyword">struct </span>ArchiveLoadImpl&lt;Archive,linked_list&gt; {</div>
<div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structmadness_1_1archive_1_1ArchiveLoadImpl.html#ae3fde4dc6adb014d0e7fc12c56ba14a7">load</a>(<span class="keyword">const</span> Archive&amp; ar, linked_list&amp; c) {</div>
<div class="line">          <span class="keywordtype">int</span> value;  <span class="keywordtype">bool</span> flag;</div>
<div class="line">          ar &amp; value &amp; flag;</div>
<div class="line">          c.set_value(value);</div>
<div class="line">          <span class="keywordflow">if</span> (flag) {</div>
<div class="line">              c.append(0);</div>
<div class="line">              ar &amp; *c.get_next();</div>
<div class="line">          }</div>
<div class="line">            };</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Given the above implementation of a linked list, you can (de)serialize an entire list using a single statement. </p><div class="fragment"><div class="line">linked_list list(0);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;=10; ++i) list.append(i);</div>
<div class="line">BinaryFstreamOutputArchive ar(<span class="stringliteral">&#39;list.dat&#39;</span>);</div>
<div class="line">ar &amp; list;</div>
</div><!-- fragment --><dl class="section user"><dt>Non-default constructor</dt><dd></dd></dl>
<p>There are various options for objects that do not have a default constructor. The most appealing and totally non-intrusive approach is to define load/store functions for a pointer to the object. Then in the load method you can deserialize all of the information necessary to invoke the constructor and return a pointer to a new object.</p>
<p>Things that you know are contiguously stored in memory and are painful to serialize with full type safety can be serialized by wrapping opaquely as byte streams using the <code><a class="el" href="namespacemadness_1_1archive.html#ac8dabd2ca613f5efe62a36786a929e9b" title="Factory function to wrap contiguous scalar as opaque (uchar) archive_array. ">wrap_opaque()</a></code> interface. However, this should be regarded as a last resort.</p>
<dl class="section user"><dt>Type checking and registering your own types</dt><dd></dd></dl>
<p>To enable type checking for user-defined types you must register them with the system. There are 64 empty slots for user types beginning at cookie=128. Type checked archives (currently all except the MPI archive) store a cookie (byte with value 0-255) with each datum. Unknown (user-defined) types all end up with the same cookie indicating unkown &mdash; i.e., no type checking unless you register.</p>
<p>Two steps are required to register your own types (e.g., here for the types <code>Foo</code> and <code>Bar</code> )</p><ol type="1">
<li>In a header file after including <a class="el" href="archive_8h.html" title="Interface templates for the archives (serialization) ">world/archive.h</a>, associate your types and pointers to them with cookie values <div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacemadness.html">madness</a> {</div>
<div class="line">    <span class="keyword">namespace </span>archive {</div>
<div class="line">        <a class="code" href="namespacemadness_1_1archive.html#a0a23d2f4cf67a728622800e4f48f9737">ARCHIVE_REGISTER_TYPE_AND_PTR</a>(Foo,128);</div>
<div class="line">        <a class="code" href="namespacemadness_1_1archive.html#a0a23d2f4cf67a728622800e4f48f9737">ARCHIVE_REGISTER_TYPE_AND_PTR</a>(Bar,129);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>In a single source file containing your initialization routine define a macro to force instantiation of relevant templates <div class="fragment"><div class="line"><span class="preprocessor">#define ARCHIVE_REGISTER_TYPE_INSTANTIATE_HERE</span></div>
</div><!-- fragment --> and then in the initalization routine register the name of your types as follows <div class="fragment"><div class="line"><a class="code" href="archive_8h.html#a2b36a16c962867eb666fc85a1cf7f9c9">ARCHIVE_REGISTER_TYPE_AND_PTR_NAMES</a>(Foo);</div>
<div class="line"><a class="code" href="archive_8h.html#a2b36a16c962867eb666fc85a1cf7f9c9">ARCHIVE_REGISTER_TYPE_AND_PTR_NAMES</a>(Bar);</div>
</div><!-- fragment --> Have a look at <a href="http://code.google.com/p/m-a-d-n-e-s-s/source/browse/local/trunk/src/lib/world/testar.cc">this test code</a>. to see things in action.</li>
</ol>
<dl class="section user"><dt>Types of archive</dt><dd></dd></dl>
<p>Presently provided are</p><ul>
<li><a class="el" href="textfsar_8h.html" title="Implements archive wrapping text file stream. ">world/textfsar.h</a> &mdash; (text <code>std::fstream</code> ) a file in text (XML)</li>
<li><a class="el" href="binfsar_8h.html" title="Implements archive wrapping a binary filestream. ">world/binfsar.h</a> &mdash; (binary <code>std::fstream</code> ) a file in binary</li>
<li><a class="el" href="vecar_8h.html" title="Implements archive wrapping an STL vector. ">world/vecar.h</a> &mdash; binary in memory using an <code>std::vector&lt;unsigned_char&gt;</code> </li>
<li><a class="el" href="bufar_8h.html" title="Implements an archive wrapping a memory buffer. ">world/bufar.h</a> &mdash; binary in memory buffer (this is rather heavily specialized for internal use so applications should use a vector instead)</li>
<li><a class="el" href="mpiar_8h.html">world/mpiar.h</a> &mdash; binary stream for point-to-point communication using MPI (non-typesafe for efficiency).</li>
<li><a class="el" href="parar_8h.html" title="Implements ParallelInputArchive and ParallelOutputArchive. ">world/parar.h</a> &mdash; parallel archive to binary file with multiple readers/writers. Mostly to support efficient transfer of large WorldContainer (<a class="el" href="worlddc_8h.html" title="Implements WorldContainer. ">world/worlddc.h</a>) and MADNESS Function (<a class="el" href="mra_8h.html" title="Main include file for MADNESS and defines Function interface. ">mra/mra.h</a>) objects, though any serialiable object can employ it.</li>
</ul>
<p>The buffer and <code>vector</code> archives are bitwise identical to the binary file archive.</p>
<dl class="section user"><dt>Implementing a new archive</dt><dd></dd></dl>
<p>Minimally, an archive must derive from either BaseInputArchive or BaseOutputArchive and define for arrays of fundamental types either a <code>load</code> or <code>store</code> method, as appropriate. Additional methods can be provided to manipulate the target stream. Here is a simple, but functional, implementation of a binary file archive. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="archive_8h.html">madness/world/archive.h</a>&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div>
<div class="line"><span class="keyword">class </span>OutputArchive : <span class="keyword">public</span> BaseOutputArchive {</div>
<div class="line">  <span class="keyword">mutable</span> ofstream os;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  OutputArchive(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename)</div>
<div class="line">    : os(filename, ios_base::binary | ios_base::out | ios_base::<a class="code" href="namespacempfr.html#ad9ff6cc8c4fb467a66d4d77f504482df">trunc</a>) {};</div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line">  <span class="keywordtype">void</span> store(<span class="keyword">const</span> <a class="code" href="namespacestd_1_1tr1.html#a997603b2d09924bf040b5dcd9eac7f7b">T</a>* t, <span class="keywordtype">long</span> n)<span class="keyword"> const </span>{</div>
<div class="line">    os.write((<span class="keyword">const</span> <span class="keywordtype">char</span> *) t, n*<span class="keyword">sizeof</span>(<a class="code" href="namespacestd_1_1tr1.html#a997603b2d09924bf040b5dcd9eac7f7b">T</a>));</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>InputArchive : <span class="keyword">public</span> BaseInputArchive {</div>
<div class="line">  <span class="keyword">mutable</span> ifstream is;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  InputArchive(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename)</div>
<div class="line">    : is(filename, ios_base::binary | ios_base::in) {};</div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="helium__exact_8cc.html#a7a600bef61227564acad9bec067e7c98">load</a>(<a class="code" href="namespacestd_1_1tr1.html#a997603b2d09924bf040b5dcd9eac7f7b">T</a>* t, <span class="keywordtype">long</span> n)<span class="keyword"> const </span>{</div>
<div class="line">    is.read((<span class="keywordtype">char</span> *) t, n*<span class="keyword">sizeof</span>(<a class="code" href="namespacestd_1_1tr1.html#a997603b2d09924bf040b5dcd9eac7f7b">T</a>));</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 26 2014 10:39:30 for MADNESS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
