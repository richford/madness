<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>MADNESS: madness::WorldContainer&lt; keyT, valueT, hashfunT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MADNESS
   &#160;<span id="projectnumber">version 0.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemadness.html">madness</a></li><li class="navelem"><a class="el" href="singletonmadness_1_1WorldContainer.html">WorldContainer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmadness_1_1WorldContainer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">madness::WorldContainer&lt; keyT, valueT, hashfunT &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__libraries.html">MADNESS libraries</a> &raquo; <a class="el" href="group__parallel__runtime.html">Parallel programming environment</a> &raquo; <a class="el" href="group__worlddc.html">Distributed containers (WorldContainer)</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Makes a distributed container with specified attributes.  
 <a href="singletonmadness_1_1WorldContainer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="worlddc_8h_source.html">worlddc.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for madness::WorldContainer&lt; keyT, valueT, hashfunT &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="singletonmadness_1_1WorldContainer__inherit__graph.png" border="0" usemap="#madness_1_1WorldContainer_3_01keyT_00_01valueT_00_01hashfunT_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="madness_1_1WorldContainer_3_01keyT_00_01valueT_00_01hashfunT_01_4_inherit__map" id="madness_1_1WorldContainer_3_01keyT_00_01valueT_00_01hashfunT_01_4_inherit__map">
<area shape="rect" id="node2" href="classmadness_1_1archive_1_1ParallelSerializableObject.html" title="Objects that implement their own parallel archive interface should derive from this. " alt="" coords="10,5,197,49"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for madness::WorldContainer&lt; keyT, valueT, hashfunT &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="singletonmadness_1_1WorldContainer__coll__graph.png" border="0" usemap="#madness_1_1WorldContainer_3_01keyT_00_01valueT_00_01hashfunT_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="madness_1_1WorldContainer_3_01keyT_00_01valueT_00_01hashfunT_01_4_coll__map" id="madness_1_1WorldContainer_3_01keyT_00_01valueT_00_01hashfunT_01_4_coll__map">
<area shape="rect" id="node2" href="classmadness_1_1archive_1_1ParallelSerializableObject.html" title="Objects that implement their own parallel archive interface should derive from this. " alt="" coords="10,5,197,49"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a76541de6b3a4625db55abd0fb13b3e4e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="singletonmadness_1_1WorldContainer.html">WorldContainer</a>&lt; keyT, <br class="typebreak" />
valueT, hashfunT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a76541de6b3a4625db55abd0fb13b3e4e">containerT</a></td></tr>
<tr class="separator:a76541de6b3a4625db55abd0fb13b3e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4af99052090eff40f31ebc9da74b087"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="singletonmadness_1_1WorldContainerImpl.html">WorldContainerImpl</a><br class="typebreak" />
&lt; keyT, valueT, hashfunT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#af4af99052090eff40f31ebc9da74b087">implT</a></td></tr>
<tr class="separator:af4af99052090eff40f31ebc9da74b087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5de3ee1a42b959d182a4d68649f21ae"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="singletonmadness_1_1WorldContainerImpl.html#a63eee3183f4297b4287d3831a5a99665">implT::pairT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#aa5de3ee1a42b959d182a4d68649f21ae">pairT</a></td></tr>
<tr class="separator:aa5de3ee1a42b959d182a4d68649f21ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e791b5a3fc38f5ea812aaa95f960358"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="singletonmadness_1_1WorldContainerImpl.html#a0310fa35bc61ca4b406fc0cf09d84f14">implT::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a9e791b5a3fc38f5ea812aaa95f960358">iterator</a></td></tr>
<tr class="separator:a9e791b5a3fc38f5ea812aaa95f960358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cb3fd7bebc9d099d9bbd5604dad7c5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="singletonmadness_1_1WorldContainerImpl.html#afc27f83bd8661f84328b568b3087f701">implT::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a35cb3fd7bebc9d099d9bbd5604dad7c5">const_iterator</a></td></tr>
<tr class="separator:a35cb3fd7bebc9d099d9bbd5604dad7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1d939195a25f8a55566630b3758aa9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="singletonmadness_1_1WorldContainerImpl.html#a099a5c64408d2afe4b7ec3873b74bb50">implT::accessor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#aff1d939195a25f8a55566630b3758aa9">accessor</a></td></tr>
<tr class="separator:aff1d939195a25f8a55566630b3758aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87d6b2d720e96bb054aae89273e601a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="singletonmadness_1_1WorldContainerImpl.html#afff679e14ff06be1ca8c769f923b5ee0">implT::const_accessor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#ad87d6b2d720e96bb054aae89273e601a">const_accessor</a></td></tr>
<tr class="separator:ad87d6b2d720e96bb054aae89273e601a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1d561daef2f7cd34442dc379a46da9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="singletonmadness_1_1WorldContainer.html#a9e791b5a3fc38f5ea812aaa95f960358">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a7d1d561daef2f7cd34442dc379a46da9">futureT</a></td></tr>
<tr class="separator:a7d1d561daef2f7cd34442dc379a46da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c35982c32b11f3b712d1afed6179770"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="singletonmadness_1_1WorldContainer.html#a35cb3fd7bebc9d099d9bbd5604dad7c5">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a2c35982c32b11f3b712d1afed6179770">const_futureT</a></td></tr>
<tr class="separator:a2c35982c32b11f3b712d1afed6179770"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a44b5ea4ba9c352b697ac832590cbb0bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a44b5ea4ba9c352b697ac832590cbb0bb">WorldContainer</a> ()</td></tr>
<tr class="memdesc:a44b5ea4ba9c352b697ac832590cbb0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an uninitialized container (no communication)  <a href="#a44b5ea4ba9c352b697ac832590cbb0bb">More...</a><br /></td></tr>
<tr class="separator:a44b5ea4ba9c352b697ac832590cbb0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0580012bb71be636b6a5a41d857acaae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a0580012bb71be636b6a5a41d857acaae">WorldContainer</a> (<a class="el" href="classmadness_1_1World.html">World</a> &amp;world, bool do_pending=true, const hashfunT &amp;hf=hashfunT())</td></tr>
<tr class="memdesc:a0580012bb71be636b6a5a41d857acaae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an initialized, empty container with default data distribution (no communication)  <a href="#a0580012bb71be636b6a5a41d857acaae">More...</a><br /></td></tr>
<tr class="separator:a0580012bb71be636b6a5a41d857acaae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abd69a62351af92c17d0d99c8436bde"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a1abd69a62351af92c17d0d99c8436bde">WorldContainer</a> (<a class="el" href="classmadness_1_1World.html">World</a> &amp;world, const <a class="el" href="singletonmadness_1_1tr1_1_1shptr_1_1shared__ptr.html">std::shared_ptr</a>&lt; <a class="el" href="singletonmadness_1_1WorldDCPmapInterface.html">WorldDCPmapInterface</a>&lt; keyT &gt; &gt; &amp;pmap, bool do_pending=true, const hashfunT &amp;hf=hashfunT())</td></tr>
<tr class="memdesc:a1abd69a62351af92c17d0d99c8436bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an initialized, empty container (no communication)  <a href="#a1abd69a62351af92c17d0d99c8436bde">More...</a><br /></td></tr>
<tr class="separator:a1abd69a62351af92c17d0d99c8436bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d364ab66e92ffb4834f0dc7a0cb151"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a85d364ab66e92ffb4834f0dc7a0cb151">WorldContainer</a> (const <a class="el" href="singletonmadness_1_1WorldContainer.html">WorldContainer</a> &amp;other)</td></tr>
<tr class="memdesc:a85d364ab66e92ffb4834f0dc7a0cb151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is shallow (no communication)  <a href="#a85d364ab66e92ffb4834f0dc7a0cb151">More...</a><br /></td></tr>
<tr class="separator:a85d364ab66e92ffb4834f0dc7a0cb151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4e5f58edc5f8eebe28fbf1a1299315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1WorldContainer.html#a76541de6b3a4625db55abd0fb13b3e4e">containerT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#acf4e5f58edc5f8eebe28fbf1a1299315">operator=</a> (const <a class="el" href="singletonmadness_1_1WorldContainer.html#a76541de6b3a4625db55abd0fb13b3e4e">containerT</a> &amp;other)</td></tr>
<tr class="memdesc:acf4e5f58edc5f8eebe28fbf1a1299315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment is shallow (no communication)  <a href="#acf4e5f58edc5f8eebe28fbf1a1299315">More...</a><br /></td></tr>
<tr class="separator:acf4e5f58edc5f8eebe28fbf1a1299315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af761298a39e16a522fa1f15dfd09ed5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmadness_1_1World.html">World</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#af761298a39e16a522fa1f15dfd09ed5d">get_world</a> () const </td></tr>
<tr class="memdesc:af761298a39e16a522fa1f15dfd09ed5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the world associated with this container.  <a href="#af761298a39e16a522fa1f15dfd09ed5d">More...</a><br /></td></tr>
<tr class="separator:af761298a39e16a522fa1f15dfd09ed5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2fe70f494016ced802385bab5adda2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a6e2fe70f494016ced802385bab5adda2">replace</a> (const <a class="el" href="singletonmadness_1_1WorldContainer.html#aa5de3ee1a42b959d182a4d68649f21ae">pairT</a> &amp;datum)</td></tr>
<tr class="memdesc:a6e2fe70f494016ced802385bab5adda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts/replaces key+value pair (non-blocking communication if key not local)  <a href="#a6e2fe70f494016ced802385bab5adda2">More...</a><br /></td></tr>
<tr class="separator:a6e2fe70f494016ced802385bab5adda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c0a8c68cfa837299bea290a9c2cef6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a16c0a8c68cfa837299bea290a9c2cef6">replace</a> (const keyT &amp;key, const valueT &amp;value)</td></tr>
<tr class="memdesc:a16c0a8c68cfa837299bea290a9c2cef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts/replaces key+value pair (non-blocking communication if key not local)  <a href="#a16c0a8c68cfa837299bea290a9c2cef6">More...</a><br /></td></tr>
<tr class="separator:a16c0a8c68cfa837299bea290a9c2cef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0471987c01e9d46eccad3698bfad3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a0b0471987c01e9d46eccad3698bfad3d">find</a> (<a class="el" href="singletonmadness_1_1WorldContainer.html#aff1d939195a25f8a55566630b3758aa9">accessor</a> &amp;acc, const keyT &amp;key)</td></tr>
<tr class="memdesc:a0b0471987c01e9d46eccad3698bfad3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write access to LOCAL value by key. Returns true if found, false otherwise (always false for remote).  <a href="#a0b0471987c01e9d46eccad3698bfad3d">More...</a><br /></td></tr>
<tr class="separator:a0b0471987c01e9d46eccad3698bfad3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38700f69dacc4eac22ae82b5da424378"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a38700f69dacc4eac22ae82b5da424378">find</a> (<a class="el" href="singletonmadness_1_1WorldContainer.html#ad87d6b2d720e96bb054aae89273e601a">const_accessor</a> &amp;acc, const keyT &amp;key) const </td></tr>
<tr class="memdesc:a38700f69dacc4eac22ae82b5da424378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read access to LOCAL value by key. Returns true if found, false otherwise (always false for remote).  <a href="#a38700f69dacc4eac22ae82b5da424378">More...</a><br /></td></tr>
<tr class="separator:a38700f69dacc4eac22ae82b5da424378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd86d2f216f8d18d3729d660688ed38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a7cd86d2f216f8d18d3729d660688ed38">insert</a> (<a class="el" href="singletonmadness_1_1WorldContainer.html#aff1d939195a25f8a55566630b3758aa9">accessor</a> &amp;acc, const keyT &amp;key)</td></tr>
<tr class="memdesc:a7cd86d2f216f8d18d3729d660688ed38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write access to LOCAL value by key. Returns true if inserted, false if already exists (throws if remote)  <a href="#a7cd86d2f216f8d18d3729d660688ed38">More...</a><br /></td></tr>
<tr class="separator:a7cd86d2f216f8d18d3729d660688ed38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1735eb753372d4538e251c2affaa279a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a1735eb753372d4538e251c2affaa279a">insert</a> (<a class="el" href="singletonmadness_1_1WorldContainer.html#ad87d6b2d720e96bb054aae89273e601a">const_accessor</a> &amp;acc, const keyT &amp;key)</td></tr>
<tr class="memdesc:a1735eb753372d4538e251c2affaa279a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read access to LOCAL value by key. Returns true if inserted, false if already exists (throws if remote)  <a href="#a1735eb753372d4538e251c2affaa279a">More...</a><br /></td></tr>
<tr class="separator:a1735eb753372d4538e251c2affaa279a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c00aed66223ebe9b0f24ba1f766709d"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator &gt; </td></tr>
<tr class="memitem:a7c00aed66223ebe9b0f24ba1f766709d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a7c00aed66223ebe9b0f24ba1f766709d">replace</a> (input_iterator &amp;start, input_iterator &amp;<a class="el" href="singletonmadness_1_1WorldContainer.html#a70c0a1d6e1dddb3bf57c27fa93ed88f2">end</a>)</td></tr>
<tr class="memdesc:a7c00aed66223ebe9b0f24ba1f766709d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts pairs (non-blocking communication if key(s) not local)  <a href="#a7c00aed66223ebe9b0f24ba1f766709d">More...</a><br /></td></tr>
<tr class="separator:a7c00aed66223ebe9b0f24ba1f766709d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7dcc9d0d33a281dee3c1e963c90865"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a0c7dcc9d0d33a281dee3c1e963c90865">probe</a> (const keyT &amp;key) const </td></tr>
<tr class="memdesc:a0c7dcc9d0d33a281dee3c1e963c90865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if local data is immediately available (no communication)  <a href="#a0c7dcc9d0d33a281dee3c1e963c90865">More...</a><br /></td></tr>
<tr class="separator:a0c7dcc9d0d33a281dee3c1e963c90865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09b294448286e7aa7e4011ce358e585"><td class="memItemLeft" align="right" valign="top"><a class="el" href="worldtypes_8h.html#a001bdf5fdc48ff6502265ebdc8c0f148">ProcessID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#ab09b294448286e7aa7e4011ce358e585">owner</a> (const keyT &amp;key) const </td></tr>
<tr class="memdesc:ab09b294448286e7aa7e4011ce358e585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns processor that logically owns key (no communication)  <a href="#ab09b294448286e7aa7e4011ce358e585">More...</a><br /></td></tr>
<tr class="separator:ab09b294448286e7aa7e4011ce358e585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a86a26e1a2809f3bc359500b654ca4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a6a86a26e1a2809f3bc359500b654ca4b">is_local</a> (const keyT &amp;key) const </td></tr>
<tr class="memdesc:a6a86a26e1a2809f3bc359500b654ca4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the key maps to the local processor (no communication)  <a href="#a6a86a26e1a2809f3bc359500b654ca4b">More...</a><br /></td></tr>
<tr class="separator:a6a86a26e1a2809f3bc359500b654ca4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643f7d88ee8385d88cb21e6911b77f93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="singletonmadness_1_1WorldContainer.html#a9e791b5a3fc38f5ea812aaa95f960358">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a643f7d88ee8385d88cb21e6911b77f93">find</a> (const keyT &amp;key)</td></tr>
<tr class="memdesc:a643f7d88ee8385d88cb21e6911b77f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a future iterator (non-blocking communication if key not local)  <a href="#a643f7d88ee8385d88cb21e6911b77f93">More...</a><br /></td></tr>
<tr class="separator:a643f7d88ee8385d88cb21e6911b77f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a89f2011fbed581016bc316286a48dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="singletonmadness_1_1WorldContainer.html#a35cb3fd7bebc9d099d9bbd5604dad7c5">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a5a89f2011fbed581016bc316286a48dc">find</a> (const keyT &amp;key) const </td></tr>
<tr class="memdesc:a5a89f2011fbed581016bc316286a48dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a future iterator (non-blocking communication if key not local)  <a href="#a5a89f2011fbed581016bc316286a48dc">More...</a><br /></td></tr>
<tr class="separator:a5a89f2011fbed581016bc316286a48dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18677e00e87a46f4e2365149866db10b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1WorldContainer.html#a9e791b5a3fc38f5ea812aaa95f960358">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a18677e00e87a46f4e2365149866db10b">begin</a> ()</td></tr>
<tr class="memdesc:a18677e00e87a46f4e2365149866db10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the <em>local</em> data (no communication)  <a href="#a18677e00e87a46f4e2365149866db10b">More...</a><br /></td></tr>
<tr class="separator:a18677e00e87a46f4e2365149866db10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897f41222d9658504b88d8904a52083b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1WorldContainer.html#a35cb3fd7bebc9d099d9bbd5604dad7c5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a897f41222d9658504b88d8904a52083b">begin</a> () const </td></tr>
<tr class="memdesc:a897f41222d9658504b88d8904a52083b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the <em>local</em> data (no communication)  <a href="#a897f41222d9658504b88d8904a52083b">More...</a><br /></td></tr>
<tr class="separator:a897f41222d9658504b88d8904a52083b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c0a1d6e1dddb3bf57c27fa93ed88f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1WorldContainer.html#a9e791b5a3fc38f5ea812aaa95f960358">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a70c0a1d6e1dddb3bf57c27fa93ed88f2">end</a> ()</td></tr>
<tr class="memdesc:a70c0a1d6e1dddb3bf57c27fa93ed88f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator past the end of the <em>local</em> data (no communication)  <a href="#a70c0a1d6e1dddb3bf57c27fa93ed88f2">More...</a><br /></td></tr>
<tr class="separator:a70c0a1d6e1dddb3bf57c27fa93ed88f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266b89315762fc6da067d393dd6f030e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1WorldContainer.html#a35cb3fd7bebc9d099d9bbd5604dad7c5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a266b89315762fc6da067d393dd6f030e">end</a> () const </td></tr>
<tr class="memdesc:a266b89315762fc6da067d393dd6f030e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator past the end of the <em>local</em> data (no communication)  <a href="#a266b89315762fc6da067d393dd6f030e">More...</a><br /></td></tr>
<tr class="separator:a266b89315762fc6da067d393dd6f030e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c28252d7728e2f147560acc372de02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a57c28252d7728e2f147560acc372de02">erase</a> (const keyT &amp;key)</td></tr>
<tr class="memdesc:a57c28252d7728e2f147560acc372de02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases entry from container (non-blocking comm if remote)  <a href="#a57c28252d7728e2f147560acc372de02">More...</a><br /></td></tr>
<tr class="separator:a57c28252d7728e2f147560acc372de02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807b5392da4f974189c42264f498bb83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a807b5392da4f974189c42264f498bb83">erase</a> (const <a class="el" href="singletonmadness_1_1WorldContainer.html#a9e791b5a3fc38f5ea812aaa95f960358">iterator</a> &amp;it)</td></tr>
<tr class="memdesc:a807b5392da4f974189c42264f498bb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases entry corresponding to <em>local</em> iterator (no communication)  <a href="#a807b5392da4f974189c42264f498bb83">More...</a><br /></td></tr>
<tr class="separator:a807b5392da4f974189c42264f498bb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8316a8a6c63a987144f1742d41255e5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a8316a8a6c63a987144f1742d41255e5c">erase</a> (const <a class="el" href="singletonmadness_1_1WorldContainer.html#a9e791b5a3fc38f5ea812aaa95f960358">iterator</a> &amp;start, const <a class="el" href="singletonmadness_1_1WorldContainer.html#a9e791b5a3fc38f5ea812aaa95f960358">iterator</a> &amp;finish)</td></tr>
<tr class="memdesc:a8316a8a6c63a987144f1742d41255e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases range defined by <em>local</em> iterators (no communication)  <a href="#a8316a8a6c63a987144f1742d41255e5c">More...</a><br /></td></tr>
<tr class="separator:a8316a8a6c63a987144f1742d41255e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34bc4bbc8c2ba4306a91b5d4a1d05db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#ad34bc4bbc8c2ba4306a91b5d4a1d05db">clear</a> ()</td></tr>
<tr class="memdesc:ad34bc4bbc8c2ba4306a91b5d4a1d05db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all <em>local</em> data (no communication)  <a href="#ad34bc4bbc8c2ba4306a91b5d4a1d05db">More...</a><br /></td></tr>
<tr class="separator:ad34bc4bbc8c2ba4306a91b5d4a1d05db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af415676e3d9721768a6f457144091557"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#af415676e3d9721768a6f457144091557">size</a> () const </td></tr>
<tr class="memdesc:af415676e3d9721768a6f457144091557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <em>local</em> entries (no communication)  <a href="#af415676e3d9721768a6f457144091557">More...</a><br /></td></tr>
<tr class="separator:af415676e3d9721768a6f457144091557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd3bfeea82fe9ee38a8c7bf1916844c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="singletonmadness_1_1tr1_1_1shptr_1_1shared__ptr.html">std::shared_ptr</a><br class="typebreak" />
&lt; <a class="el" href="singletonmadness_1_1WorldDCPmapInterface.html">WorldDCPmapInterface</a>&lt; keyT &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#aefd3bfeea82fe9ee38a8c7bf1916844c">get_pmap</a> () const </td></tr>
<tr class="memdesc:aefd3bfeea82fe9ee38a8c7bf1916844c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns shared pointer to the process mapping.  <a href="#aefd3bfeea82fe9ee38a8c7bf1916844c">More...</a><br /></td></tr>
<tr class="separator:aefd3bfeea82fe9ee38a8c7bf1916844c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd0ffcec2674a8951c29cd48691850f"><td class="memItemLeft" align="right" valign="top">hashfunT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a0fd0ffcec2674a8951c29cd48691850f">get_hash</a> () const </td></tr>
<tr class="memdesc:a0fd0ffcec2674a8951c29cd48691850f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the hashing functor.  <a href="#a0fd0ffcec2674a8951c29cd48691850f">More...</a><br /></td></tr>
<tr class="separator:a0fd0ffcec2674a8951c29cd48691850f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d4e7b5aee2f829ac6405504a209cee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a03d4e7b5aee2f829ac6405504a209cee">process_pending</a> ()</td></tr>
<tr class="memdesc:a03d4e7b5aee2f829ac6405504a209cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process pending messages.  <a href="#a03d4e7b5aee2f829ac6405504a209cee">More...</a><br /></td></tr>
<tr class="separator:a03d4e7b5aee2f829ac6405504a209cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09200e32d824253061dca50cade7327c"><td class="memTemplParams" colspan="2">template&lt;typename memfunT &gt; </td></tr>
<tr class="memitem:a09200e32d824253061dca50cade7327c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a09200e32d824253061dca50cade7327c">send</a> (const keyT &amp;key, memfunT memfun)</td></tr>
<tr class="memdesc:a09200e32d824253061dca50cade7327c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends message "resultT memfun()" to item (non-blocking comm if remote)  <a href="#a09200e32d824253061dca50cade7327c">More...</a><br /></td></tr>
<tr class="separator:a09200e32d824253061dca50cade7327c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e32c17bd9d4c52ad5e618f09e9f6e7d"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T &gt; </td></tr>
<tr class="memitem:a4e32c17bd9d4c52ad5e618f09e9f6e7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a4e32c17bd9d4c52ad5e618f09e9f6e7d">send</a> (const keyT &amp;key, const memfunT &amp;memfun, const arg1T &amp;arg1)</td></tr>
<tr class="memdesc:a4e32c17bd9d4c52ad5e618f09e9f6e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends message "resultT memfun(arg1T)" to item (non-blocking comm if remote)  <a href="#a4e32c17bd9d4c52ad5e618f09e9f6e7d">More...</a><br /></td></tr>
<tr class="separator:a4e32c17bd9d4c52ad5e618f09e9f6e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba80a61b03f59f70dfdd6ec3f8e76df1"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T &gt; </td></tr>
<tr class="memitem:aba80a61b03f59f70dfdd6ec3f8e76df1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#aba80a61b03f59f70dfdd6ec3f8e76df1">send</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2)</td></tr>
<tr class="memdesc:aba80a61b03f59f70dfdd6ec3f8e76df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends message "resultT memfun(arg1T,arg2T)" to item (non-blocking comm if remote)  <a href="#aba80a61b03f59f70dfdd6ec3f8e76df1">More...</a><br /></td></tr>
<tr class="separator:aba80a61b03f59f70dfdd6ec3f8e76df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cb28c1908ab480e3144aaaf7f91a19"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T &gt; </td></tr>
<tr class="memitem:a46cb28c1908ab480e3144aaaf7f91a19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a46cb28c1908ab480e3144aaaf7f91a19">send</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const arg3T &amp;arg3)</td></tr>
<tr class="memdesc:a46cb28c1908ab480e3144aaaf7f91a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends message "resultT memfun(arg1T,arg2T,arg3T)" to item (non-blocking comm if remote)  <a href="#a46cb28c1908ab480e3144aaaf7f91a19">More...</a><br /></td></tr>
<tr class="separator:a46cb28c1908ab480e3144aaaf7f91a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bdd5728e78c986f7c36447c7ab2eed"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T &gt; </td></tr>
<tr class="memitem:a40bdd5728e78c986f7c36447c7ab2eed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a40bdd5728e78c986f7c36447c7ab2eed">send</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const arg3T &amp;arg3, const arg4T &amp;arg4)</td></tr>
<tr class="memdesc:a40bdd5728e78c986f7c36447c7ab2eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends message "resultT memfun(arg1T,arg2T,arg3T,arg4T)" to item (non-blocking comm if remote)  <a href="#a40bdd5728e78c986f7c36447c7ab2eed">More...</a><br /></td></tr>
<tr class="separator:a40bdd5728e78c986f7c36447c7ab2eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaba470ffd9246ed91b17184c98f27de"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T &gt; </td></tr>
<tr class="memitem:aaaba470ffd9246ed91b17184c98f27de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#aaaba470ffd9246ed91b17184c98f27de">send</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const arg3T &amp;arg3, const arg4T &amp;arg4, const arg5T &amp;arg5)</td></tr>
<tr class="memdesc:aaaba470ffd9246ed91b17184c98f27de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends message "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T)" to item (non-blocking comm if remote)  <a href="#aaaba470ffd9246ed91b17184c98f27de">More...</a><br /></td></tr>
<tr class="separator:aaaba470ffd9246ed91b17184c98f27de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe7bba801fe7c24d02428fda359fbe4"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T , typename arg6T &gt; </td></tr>
<tr class="memitem:a8fe7bba801fe7c24d02428fda359fbe4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a8fe7bba801fe7c24d02428fda359fbe4">send</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const arg3T &amp;arg3, const arg4T &amp;arg4, const arg5T &amp;arg5, const arg6T &amp;arg6)</td></tr>
<tr class="memdesc:a8fe7bba801fe7c24d02428fda359fbe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends message "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T,arg6T)" to item (non-blocking comm if remote)  <a href="#a8fe7bba801fe7c24d02428fda359fbe4">More...</a><br /></td></tr>
<tr class="separator:a8fe7bba801fe7c24d02428fda359fbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786052953d0cb91fc50cc5f11ea6bdb1"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T , typename arg6T , typename arg7T &gt; </td></tr>
<tr class="memitem:a786052953d0cb91fc50cc5f11ea6bdb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a786052953d0cb91fc50cc5f11ea6bdb1">send</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const arg3T &amp;arg3, const arg4T &amp;arg4, const arg5T &amp;arg5, const arg6T &amp;arg6, const arg7T &amp;arg7)</td></tr>
<tr class="memdesc:a786052953d0cb91fc50cc5f11ea6bdb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends message "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T,arg6T,arg7T)" to item (non-blocking comm if remote)  <a href="#a786052953d0cb91fc50cc5f11ea6bdb1">More...</a><br /></td></tr>
<tr class="separator:a786052953d0cb91fc50cc5f11ea6bdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c915bb6305bdc4b61d651206cdaaaf5"><td class="memTemplParams" colspan="2">template&lt;typename memfunT &gt; </td></tr>
<tr class="memitem:a4c915bb6305bdc4b61d651206cdaaaf5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a4c915bb6305bdc4b61d651206cdaaaf5">send</a> (const keyT &amp;key, memfunT memfun) const </td></tr>
<tr class="memdesc:a4c915bb6305bdc4b61d651206cdaaaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends message "resultT memfun() const" to item (non-blocking comm if remote)  <a href="#a4c915bb6305bdc4b61d651206cdaaaf5">More...</a><br /></td></tr>
<tr class="separator:a4c915bb6305bdc4b61d651206cdaaaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ad81529eb73e5cc4d4d1b944a3f7d9"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T &gt; </td></tr>
<tr class="memitem:a67ad81529eb73e5cc4d4d1b944a3f7d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a67ad81529eb73e5cc4d4d1b944a3f7d9">send</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1) const </td></tr>
<tr class="memdesc:a67ad81529eb73e5cc4d4d1b944a3f7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends message "resultT memfun(arg1T) const" to item (non-blocking comm if remote)  <a href="#a67ad81529eb73e5cc4d4d1b944a3f7d9">More...</a><br /></td></tr>
<tr class="separator:a67ad81529eb73e5cc4d4d1b944a3f7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa121fd6180fbaed2535dbb8f807a1b"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T &gt; </td></tr>
<tr class="memitem:a8fa121fd6180fbaed2535dbb8f807a1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a8fa121fd6180fbaed2535dbb8f807a1b">send</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2) const </td></tr>
<tr class="memdesc:a8fa121fd6180fbaed2535dbb8f807a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends message "resultT memfun(arg1T,arg2T) const" to item (non-blocking comm if remote)  <a href="#a8fa121fd6180fbaed2535dbb8f807a1b">More...</a><br /></td></tr>
<tr class="separator:a8fa121fd6180fbaed2535dbb8f807a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fbc751e41265c4809c9bd31746569f"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T &gt; </td></tr>
<tr class="memitem:a48fbc751e41265c4809c9bd31746569f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a48fbc751e41265c4809c9bd31746569f">send</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const arg3T &amp;arg3) const </td></tr>
<tr class="memdesc:a48fbc751e41265c4809c9bd31746569f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends message "resultT memfun(arg1T,arg2T,arg3T) const" to item (non-blocking comm if remote)  <a href="#a48fbc751e41265c4809c9bd31746569f">More...</a><br /></td></tr>
<tr class="separator:a48fbc751e41265c4809c9bd31746569f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d76c0317a4f3893781dc22ea6ebbbf8"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T &gt; </td></tr>
<tr class="memitem:a8d76c0317a4f3893781dc22ea6ebbbf8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a8d76c0317a4f3893781dc22ea6ebbbf8">send</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const arg3T &amp;arg3, const arg4T &amp;arg4) const </td></tr>
<tr class="memdesc:a8d76c0317a4f3893781dc22ea6ebbbf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends message "resultT memfun(arg1T,arg2T,arg3T,arg4T) const" to item (non-blocking comm if remote)  <a href="#a8d76c0317a4f3893781dc22ea6ebbbf8">More...</a><br /></td></tr>
<tr class="separator:a8d76c0317a4f3893781dc22ea6ebbbf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda2742ee88d3d3b5b2f1d16ee2b4de3"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T &gt; </td></tr>
<tr class="memitem:afda2742ee88d3d3b5b2f1d16ee2b4de3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#afda2742ee88d3d3b5b2f1d16ee2b4de3">send</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const arg3T &amp;arg3, const arg4T &amp;arg4, const arg5T &amp;arg5) const </td></tr>
<tr class="memdesc:afda2742ee88d3d3b5b2f1d16ee2b4de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends message "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T) const" to item (non-blocking comm if remote)  <a href="#afda2742ee88d3d3b5b2f1d16ee2b4de3">More...</a><br /></td></tr>
<tr class="separator:afda2742ee88d3d3b5b2f1d16ee2b4de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0009eebb76552cd71c7e303b302115"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T , typename arg6T &gt; </td></tr>
<tr class="memitem:a9a0009eebb76552cd71c7e303b302115"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a9a0009eebb76552cd71c7e303b302115">send</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const arg3T &amp;arg3, const arg4T &amp;arg4, const arg5T &amp;arg5, const arg6T &amp;arg6) const </td></tr>
<tr class="memdesc:a9a0009eebb76552cd71c7e303b302115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends message "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T,arg6T) const" to item (non-blocking comm if remote)  <a href="#a9a0009eebb76552cd71c7e303b302115">More...</a><br /></td></tr>
<tr class="separator:a9a0009eebb76552cd71c7e303b302115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6af7eff7dffcb93fb096cbcb0fc7bc"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T , typename arg6T , typename arg7T &gt; </td></tr>
<tr class="memitem:afc6af7eff7dffcb93fb096cbcb0fc7bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#afc6af7eff7dffcb93fb096cbcb0fc7bc">send</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const arg3T &amp;arg3, const arg4T &amp;arg4, const arg5T &amp;arg5, const arg6T &amp;arg6, const arg7T &amp;arg7) const </td></tr>
<tr class="memdesc:afc6af7eff7dffcb93fb096cbcb0fc7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends message "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T,arg6T,arg7T) const" to item (non-blocking comm if remote)  <a href="#afc6af7eff7dffcb93fb096cbcb0fc7bc">More...</a><br /></td></tr>
<tr class="separator:afc6af7eff7dffcb93fb096cbcb0fc7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb91e7b56f91ef4b947920798f631c5d"><td class="memTemplParams" colspan="2">template&lt;typename memfunT &gt; </td></tr>
<tr class="memitem:aeb91e7b56f91ef4b947920798f631c5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#aeb91e7b56f91ef4b947920798f631c5d">task</a> (const keyT &amp;key, memfunT memfun, const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;attr=<a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>())</td></tr>
<tr class="memdesc:aeb91e7b56f91ef4b947920798f631c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds task "resultT memfun()" in process owning item (non-blocking comm if remote)  <a href="#aeb91e7b56f91ef4b947920798f631c5d">More...</a><br /></td></tr>
<tr class="separator:aeb91e7b56f91ef4b947920798f631c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2482ce6ef6840af22f1c792c38316b7e"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T &gt; </td></tr>
<tr class="memitem:a2482ce6ef6840af22f1c792c38316b7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a2482ce6ef6840af22f1c792c38316b7e">task</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;attr=<a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>())</td></tr>
<tr class="memdesc:a2482ce6ef6840af22f1c792c38316b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds task "resultT memfun(arg1T)" in process owning item (non-blocking comm if remote)  <a href="#a2482ce6ef6840af22f1c792c38316b7e">More...</a><br /></td></tr>
<tr class="separator:a2482ce6ef6840af22f1c792c38316b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab214b3e638b425143068a4125bef43f3"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T &gt; </td></tr>
<tr class="memitem:ab214b3e638b425143068a4125bef43f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#ab214b3e638b425143068a4125bef43f3">task</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;attr=<a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>())</td></tr>
<tr class="memdesc:ab214b3e638b425143068a4125bef43f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds task "resultT memfun(arg1T,arg2T)" in process owning item (non-blocking comm if remote)  <a href="#ab214b3e638b425143068a4125bef43f3">More...</a><br /></td></tr>
<tr class="separator:ab214b3e638b425143068a4125bef43f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5b539b6e95db76fe5c2091b3521976"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T &gt; </td></tr>
<tr class="memitem:a4a5b539b6e95db76fe5c2091b3521976"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a4a5b539b6e95db76fe5c2091b3521976">task</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const arg3T &amp;arg3, const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;attr=<a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>())</td></tr>
<tr class="memdesc:a4a5b539b6e95db76fe5c2091b3521976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds task "resultT memfun(arg1T,arg2T,arg3T)" in process owning item (non-blocking comm if remote)  <a href="#a4a5b539b6e95db76fe5c2091b3521976">More...</a><br /></td></tr>
<tr class="separator:a4a5b539b6e95db76fe5c2091b3521976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168e99cadc8fd92c983dd9168858f7c8"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T &gt; </td></tr>
<tr class="memitem:a168e99cadc8fd92c983dd9168858f7c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a168e99cadc8fd92c983dd9168858f7c8">task</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const arg3T &amp;arg3, const arg4T &amp;arg4, const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;attr=<a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>())</td></tr>
<tr class="memdesc:a168e99cadc8fd92c983dd9168858f7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds task "resultT memfun(arg1T,arg2T,arg3T,arg4T)" in process owning item (non-blocking comm if remote)  <a href="#a168e99cadc8fd92c983dd9168858f7c8">More...</a><br /></td></tr>
<tr class="separator:a168e99cadc8fd92c983dd9168858f7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fd2ea28895258f3575924bf1446591"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T &gt; </td></tr>
<tr class="memitem:a97fd2ea28895258f3575924bf1446591"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a97fd2ea28895258f3575924bf1446591">task</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const arg3T &amp;arg3, const arg4T &amp;arg4, const arg5T &amp;arg5, const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;attr=<a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>())</td></tr>
<tr class="memdesc:a97fd2ea28895258f3575924bf1446591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds task "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T)" in process owning item (non-blocking comm if remote)  <a href="#a97fd2ea28895258f3575924bf1446591">More...</a><br /></td></tr>
<tr class="separator:a97fd2ea28895258f3575924bf1446591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4a0ffdd2b8ef8b61e0f5181a468ad7"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T , typename arg6T &gt; </td></tr>
<tr class="memitem:a3f4a0ffdd2b8ef8b61e0f5181a468ad7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a3f4a0ffdd2b8ef8b61e0f5181a468ad7">task</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const arg3T &amp;arg3, const arg4T &amp;arg4, const arg5T &amp;arg5, const arg6T &amp;arg6, const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;attr=<a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>())</td></tr>
<tr class="memdesc:a3f4a0ffdd2b8ef8b61e0f5181a468ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds task "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T,arg6T)" in process owning item (non-blocking comm if remote)  <a href="#a3f4a0ffdd2b8ef8b61e0f5181a468ad7">More...</a><br /></td></tr>
<tr class="separator:a3f4a0ffdd2b8ef8b61e0f5181a468ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171ccd4f6b80de77d7c60d46513cd90e"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T , typename arg6T , typename arg7T &gt; </td></tr>
<tr class="memitem:a171ccd4f6b80de77d7c60d46513cd90e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a171ccd4f6b80de77d7c60d46513cd90e">task</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const arg3T &amp;arg3, const arg4T &amp;arg4, const arg5T &amp;arg5, const arg6T &amp;arg6, const arg7T &amp;arg7, const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;attr=<a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>())</td></tr>
<tr class="memdesc:a171ccd4f6b80de77d7c60d46513cd90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds task "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T,arg6T,arg7T)" in process owning item (non-blocking comm if remote)  <a href="#a171ccd4f6b80de77d7c60d46513cd90e">More...</a><br /></td></tr>
<tr class="separator:a171ccd4f6b80de77d7c60d46513cd90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355ffe9952fc500ffd464487cbdc6fa8"><td class="memTemplParams" colspan="2">template&lt;typename memfunT &gt; </td></tr>
<tr class="memitem:a355ffe9952fc500ffd464487cbdc6fa8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a355ffe9952fc500ffd464487cbdc6fa8">task</a> (const keyT &amp;key, memfunT memfun, const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;attr=<a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()) const </td></tr>
<tr class="memdesc:a355ffe9952fc500ffd464487cbdc6fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds task "resultT memfun() const" in process owning item (non-blocking comm if remote)  <a href="#a355ffe9952fc500ffd464487cbdc6fa8">More...</a><br /></td></tr>
<tr class="separator:a355ffe9952fc500ffd464487cbdc6fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2143315c812a31198fb3d8180b415d"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T &gt; </td></tr>
<tr class="memitem:aee2143315c812a31198fb3d8180b415d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#aee2143315c812a31198fb3d8180b415d">task</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;attr=<a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()) const </td></tr>
<tr class="memdesc:aee2143315c812a31198fb3d8180b415d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds task "resultT memfun(arg1T) const" in process owning item (non-blocking comm if remote)  <a href="#aee2143315c812a31198fb3d8180b415d">More...</a><br /></td></tr>
<tr class="separator:aee2143315c812a31198fb3d8180b415d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad645f59f26afc0a1a1476661e185516d"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T &gt; </td></tr>
<tr class="memitem:ad645f59f26afc0a1a1476661e185516d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#ad645f59f26afc0a1a1476661e185516d">task</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;attr=<a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()) const </td></tr>
<tr class="memdesc:ad645f59f26afc0a1a1476661e185516d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds task "resultT memfun(arg1T,arg2T) const" in process owning item (non-blocking comm if remote)  <a href="#ad645f59f26afc0a1a1476661e185516d">More...</a><br /></td></tr>
<tr class="separator:ad645f59f26afc0a1a1476661e185516d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae369e8c5dc2ba579f533dde2ae2287d4"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T &gt; </td></tr>
<tr class="memitem:ae369e8c5dc2ba579f533dde2ae2287d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#ae369e8c5dc2ba579f533dde2ae2287d4">task</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const arg3T &amp;arg3, const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;attr=<a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()) const </td></tr>
<tr class="memdesc:ae369e8c5dc2ba579f533dde2ae2287d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds task "resultT memfun(arg1T,arg2T,arg3T) const" in process owning item (non-blocking comm if remote)  <a href="#ae369e8c5dc2ba579f533dde2ae2287d4">More...</a><br /></td></tr>
<tr class="separator:ae369e8c5dc2ba579f533dde2ae2287d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926036a5faab5ed433acdc2fd5019447"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T &gt; </td></tr>
<tr class="memitem:a926036a5faab5ed433acdc2fd5019447"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a926036a5faab5ed433acdc2fd5019447">task</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const arg3T &amp;arg3, const arg4T &amp;arg4, const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;attr=<a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()) const </td></tr>
<tr class="memdesc:a926036a5faab5ed433acdc2fd5019447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds task "resultT memfun(arg1T,arg2T,arg3T, arg4T) const" in process owning item (non-blocking comm if remote)  <a href="#a926036a5faab5ed433acdc2fd5019447">More...</a><br /></td></tr>
<tr class="separator:a926036a5faab5ed433acdc2fd5019447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5395aa2c0b0b9c928a3caa2cfe259a63"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T &gt; </td></tr>
<tr class="memitem:a5395aa2c0b0b9c928a3caa2cfe259a63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a5395aa2c0b0b9c928a3caa2cfe259a63">task</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const arg3T &amp;arg3, const arg4T &amp;arg4, const arg5T &amp;arg5, const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;attr=<a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()) const </td></tr>
<tr class="memdesc:a5395aa2c0b0b9c928a3caa2cfe259a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds task "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T) const" in process owning item (non-blocking comm if remote)  <a href="#a5395aa2c0b0b9c928a3caa2cfe259a63">More...</a><br /></td></tr>
<tr class="separator:a5395aa2c0b0b9c928a3caa2cfe259a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6adabf939a6a545f3cb8de0c447e4b"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T , typename arg6T &gt; </td></tr>
<tr class="memitem:abf6adabf939a6a545f3cb8de0c447e4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#abf6adabf939a6a545f3cb8de0c447e4b">task</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const arg3T &amp;arg3, const arg4T &amp;arg4, const arg5T &amp;arg5, const arg6T &amp;arg6, const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;attr=<a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()) const </td></tr>
<tr class="memdesc:abf6adabf939a6a545f3cb8de0c447e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds task "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T,arg6T) const" in process owning item (non-blocking comm if remote)  <a href="#abf6adabf939a6a545f3cb8de0c447e4b">More...</a><br /></td></tr>
<tr class="separator:abf6adabf939a6a545f3cb8de0c447e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2f3d287de6a8880bd4ba740b9c7f2e"><td class="memTemplParams" colspan="2">template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T , typename arg6T , typename arg7T &gt; </td></tr>
<tr class="memitem:aae2f3d287de6a8880bd4ba740b9c7f2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#aae2f3d287de6a8880bd4ba740b9c7f2e">task</a> (const keyT &amp;key, memfunT memfun, const arg1T &amp;arg1, const arg2T &amp;arg2, const arg3T &amp;arg3, const arg4T &amp;arg4, const arg5T &amp;arg5, const arg6T &amp;arg6, const arg7T &amp;arg7, const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;attr=<a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()) const </td></tr>
<tr class="memdesc:aae2f3d287de6a8880bd4ba740b9c7f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds task "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T,arg6T,arg7T) const" in process owning item (non-blocking comm if remote)  <a href="#aae2f3d287de6a8880bd4ba740b9c7f2e">More...</a><br /></td></tr>
<tr class="separator:aae2f3d287de6a8880bd4ba740b9c7f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66502d2720c995b863b648112ec4961"><td class="memTemplParams" colspan="2">template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:ac66502d2720c995b863b648112ec4961"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#ac66502d2720c995b863b648112ec4961">serialize</a> (const Archive &amp;ar)</td></tr>
<tr class="memdesc:ac66502d2720c995b863b648112ec4961"><td class="mdescLeft">&#160;</td><td class="mdescRight">(de)Serialize &mdash; <em>Local</em> data only to/from anything <em>except</em> Buffer*Archive and Parallel*Archive  <a href="#ac66502d2720c995b863b648112ec4961">More...</a><br /></td></tr>
<tr class="separator:ac66502d2720c995b863b648112ec4961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477c146f9a1c88a29ea1c67fa4d2dfd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a477c146f9a1c88a29ea1c67fa4d2dfd7">serialize</a> (const <a class="el" href="classmadness_1_1archive_1_1BufferOutputArchive.html">archive::BufferOutputArchive</a> &amp;ar)</td></tr>
<tr class="memdesc:a477c146f9a1c88a29ea1c67fa4d2dfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">(de)Serialize &mdash; !! ONLY for purpose of interprocess communication  <a href="#a477c146f9a1c88a29ea1c67fa4d2dfd7">More...</a><br /></td></tr>
<tr class="separator:a477c146f9a1c88a29ea1c67fa4d2dfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b352828b108832d63c324dd36f6399"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#ab6b352828b108832d63c324dd36f6399">serialize</a> (const <a class="el" href="classmadness_1_1archive_1_1BufferInputArchive.html">archive::BufferInputArchive</a> &amp;ar)</td></tr>
<tr class="memdesc:ab6b352828b108832d63c324dd36f6399"><td class="mdescLeft">&#160;</td><td class="mdescRight">(de)Serialize &mdash; !! ONLY for purpose of interprocess communication  <a href="#ab6b352828b108832d63c324dd36f6399">More...</a><br /></td></tr>
<tr class="separator:ab6b352828b108832d63c324dd36f6399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b223ae963f12a7e33421216b8efe2a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmadness_1_1uniqueidT.html">uniqueidT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a61b223ae963f12a7e33421216b8efe2a">id</a> () const </td></tr>
<tr class="memdesc:a61b223ae963f12a7e33421216b8efe2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the associated unique id ... must be initialized.  <a href="#a61b223ae963f12a7e33421216b8efe2a">More...</a><br /></td></tr>
<tr class="separator:a61b223ae963f12a7e33421216b8efe2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5490d784fdbaa1460e54c9bd387f55c9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a5490d784fdbaa1460e54c9bd387f55c9">~WorldContainer</a> ()</td></tr>
<tr class="memdesc:a5490d784fdbaa1460e54c9bd387f55c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor passes ownership of implementation to world for deferred cleanup.  <a href="#a5490d784fdbaa1460e54c9bd387f55c9">More...</a><br /></td></tr>
<tr class="separator:a5490d784fdbaa1460e54c9bd387f55c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a99eb11c47cfe8676bdd2073089ad8673"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonmadness_1_1WorldContainer.html#a99eb11c47cfe8676bdd2073089ad8673">swap</a> (<a class="el" href="singletonmadness_1_1WorldContainer.html">WorldContainer</a> &amp;, <a class="el" href="singletonmadness_1_1WorldContainer.html">WorldContainer</a> &amp;)</td></tr>
<tr class="memdesc:a99eb11c47cfe8676bdd2073089ad8673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the content of two <a class="el" href="singletonmadness_1_1WorldContainer.html" title="Makes a distributed container with specified attributes. ">WorldContainer</a> objects. It should be called on all nodes.  <a href="#a99eb11c47cfe8676bdd2073089ad8673">More...</a><br /></td></tr>
<tr class="separator:a99eb11c47cfe8676bdd2073089ad8673"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename keyT, typename valueT, typename hashfunT = Hash&lt;keyT&gt;&gt;<br />
class madness::WorldContainer&lt; keyT, valueT, hashfunT &gt;</h3>

<p>Makes a distributed container with specified attributes. </p>
<p>There is no communication or syncronization associated with making a new container, but every process must invoke the constructor for each container in the same order. This is so that we can assign each container a unique ID without any communication. Since remotely invoked operations may start happening before local construction, messages on not yet constructed containers are buffered pending construction.</p>
<p>Similarly, when a container is destroyed, the actual destruction is deferred until a synchronization point (world.gop.fence()) in order to eliminate the need to fence before destroying every container.</p>
<p>The distribution of data between processes is controlled by the process map (Pmap) class. The default is uniform hashing based upon a strong (Bob Jenkins, lookup3) bytewise hash of the key.</p>
<p>All operations, including constructors and destructors, are non-blocking and return immediately. If communication occurs it is asynchronous, otherwise operations are local. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aff1d939195a25f8a55566630b3758aa9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="singletonmadness_1_1WorldContainerImpl.html#a099a5c64408d2afe4b7ec3873b74bb50">implT::accessor</a> <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::<a class="el" href="singletonmadness_1_1WorldContainer.html#aff1d939195a25f8a55566630b3758aa9">accessor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad87d6b2d720e96bb054aae89273e601a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="singletonmadness_1_1WorldContainerImpl.html#afff679e14ff06be1ca8c769f923b5ee0">implT::const_accessor</a> <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::<a class="el" href="singletonmadness_1_1WorldContainer.html#ad87d6b2d720e96bb054aae89273e601a">const_accessor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2c35982c32b11f3b712d1afed6179770"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt;<a class="el" href="singletonmadness_1_1WorldContainer.html#a35cb3fd7bebc9d099d9bbd5604dad7c5">const_iterator</a>&gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::<a class="el" href="singletonmadness_1_1WorldContainer.html#a2c35982c32b11f3b712d1afed6179770">const_futureT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a35cb3fd7bebc9d099d9bbd5604dad7c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="singletonmadness_1_1WorldContainerImpl.html#afc27f83bd8661f84328b568b3087f701">implT::const_iterator</a> <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::<a class="el" href="singletonmadness_1_1WorldContainer.html#a35cb3fd7bebc9d099d9bbd5604dad7c5">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a76541de6b3a4625db55abd0fb13b3e4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="singletonmadness_1_1WorldContainer.html">WorldContainer</a>&lt;keyT,valueT,hashfunT&gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::<a class="el" href="singletonmadness_1_1WorldContainer.html#a76541de6b3a4625db55abd0fb13b3e4e">containerT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7d1d561daef2f7cd34442dc379a46da9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt;<a class="el" href="singletonmadness_1_1WorldContainer.html#a9e791b5a3fc38f5ea812aaa95f960358">iterator</a>&gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::<a class="el" href="singletonmadness_1_1WorldContainer.html#a7d1d561daef2f7cd34442dc379a46da9">futureT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af4af99052090eff40f31ebc9da74b087"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="singletonmadness_1_1WorldContainerImpl.html">WorldContainerImpl</a>&lt;keyT,valueT,hashfunT&gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::<a class="el" href="singletonmadness_1_1WorldContainer.html#af4af99052090eff40f31ebc9da74b087">implT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9e791b5a3fc38f5ea812aaa95f960358"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="singletonmadness_1_1WorldContainerImpl.html#a0310fa35bc61ca4b406fc0cf09d84f14">implT::iterator</a> <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::<a class="el" href="singletonmadness_1_1WorldContainer.html#a9e791b5a3fc38f5ea812aaa95f960358">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa5de3ee1a42b959d182a4d68649f21ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="singletonmadness_1_1WorldContainerImpl.html#a63eee3183f4297b4287d3831a5a99665">implT::pairT</a> <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::<a class="el" href="singletonmadness_1_1WorldContainer.html#aa5de3ee1a42b959d182a4d68649f21ae">pairT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a44b5ea4ba9c352b697ac832590cbb0bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::<a class="el" href="singletonmadness_1_1WorldContainer.html">WorldContainer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes an uninitialized container (no communication) </p>
<p>The container is useless until assigned to from a fully constructed container. There is no need to worry about default constructors being executed in order. </p>

</div>
</div>
<a class="anchor" id="a0580012bb71be636b6a5a41d857acaae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::<a class="el" href="singletonmadness_1_1WorldContainer.html">WorldContainer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmadness_1_1World.html">World</a> &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_pending</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hashfunT &amp;&#160;</td>
          <td class="paramname"><em>hf</em> = <code>hashfunT()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes an initialized, empty container with default data distribution (no communication) </p>
<p>A unique ID is associated with every distributed container within a world. In order to avoid synchronization when making a container, we have to assume that all processes execute this constructor in the same order (does not apply to the non-initializing, default constructor). </p>

</div>
</div>
<a class="anchor" id="a1abd69a62351af92c17d0d99c8436bde"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::<a class="el" href="singletonmadness_1_1WorldContainer.html">WorldContainer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmadness_1_1World.html">World</a> &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="singletonmadness_1_1tr1_1_1shptr_1_1shared__ptr.html">std::shared_ptr</a>&lt; <a class="el" href="singletonmadness_1_1WorldDCPmapInterface.html">WorldDCPmapInterface</a>&lt; keyT &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_pending</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hashfunT &amp;&#160;</td>
          <td class="paramname"><em>hf</em> = <code>hashfunT()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes an initialized, empty container (no communication) </p>
<p>A unique ID is associated with every distributed container within a world. In order to avoid synchronization when making a container, we have to assume that all processes execute this constructor in the same order (does not apply to the non-initializing, default constructor). </p>

</div>
</div>
<a class="anchor" id="a85d364ab66e92ffb4834f0dc7a0cb151"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::<a class="el" href="singletonmadness_1_1WorldContainer.html">WorldContainer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="singletonmadness_1_1WorldContainer.html">WorldContainer</a>&lt; keyT, valueT, hashfunT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor is shallow (no communication) </p>
<p>The copy refers to exactly the same container as other which must be initialized. </p>

</div>
</div>
<a class="anchor" id="a5490d784fdbaa1460e54c9bd387f55c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::~<a class="el" href="singletonmadness_1_1WorldContainer.html">WorldContainer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor passes ownership of implementation to world for deferred cleanup. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a18677e00e87a46f4e2365149866db10b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1WorldContainer.html#a9e791b5a3fc38f5ea812aaa95f960358">iterator</a> <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the <em>local</em> data (no communication) </p>

<p>Referenced by <a class="el" href="singletonmadness_1_1FunctionImpl.html#a4b704078131f7ecb7c7d3a976c8f58f6">madness::FunctionImpl&lt; Q, NDIM &gt;::apply()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a2f29c97ee3460c508358c745c18ed045">madness::FunctionImpl&lt; Q, NDIM &gt;::apply_1d_realspace_push()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a8db02bd27cae75e5d1a7136bf33048ac">madness::FunctionImpl&lt; Q, NDIM &gt;::apply_source_driven()</a>, <a class="el" href="singletonmadness_1_1WorldContainer.html#a897f41222d9658504b88d8904a52083b">madness::WorldContainer&lt; keyT, nodeT &gt;::begin()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a01a44d740aafcc1d25e7572c3e01da41">madness::FunctionImpl&lt; Q, NDIM &gt;::copy_coeffs()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#af70e81ec7aed49a6ced5172093afe081">madness::FunctionImpl&lt; T, NDIM &gt;::diff()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a3072f865bbef4a8796b5b6e286491ad1">madness::FunctionImpl&lt; Q, NDIM &gt;::errsq_local()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a64d1885aa7d559884ec68805f9f1b67b">madness::FunctionImpl&lt; Q, NDIM &gt;::flo_unary_op_node_inplace()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#ac1265473c71e7d40d7c4ead4d2aede45">madness::FunctionImpl&lt; Q, NDIM &gt;::FunctionImpl()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#ac2e447c0d9e9cf645257ba70d27609a7">madness::FunctionImpl&lt; Q, NDIM &gt;::gaxpy()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a8a2692a0d860c4e0bfd34f4a2798c818">madness::FunctionImpl&lt; Q, NDIM &gt;::gaxpy_inplace()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a5689d2b90ff38d77d574c4929ad66276">madness::FunctionImpl&lt; Q, NDIM &gt;::inner_ext_local()</a>, <a class="el" href="classmadness_1_1LoadBalanceDeux.html#a3d9fa5530e39fc761ebeb21c3faab581">madness::LoadBalanceDeux&lt; NDIM &gt;::load_balance()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#afb483cb2c5ffb357be03a4bf1e2d1437">madness::FunctionImpl&lt; Q, NDIM &gt;::multiop_values()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a5a044779134fabac6a1ae8147d47ce43">madness::FunctionImpl&lt; T, NDIM &gt;::project()</a>, <a class="el" href="singletonmadness_1_1WorldContainer.html#ac66502d2720c995b863b648112ec4961">madness::WorldContainer&lt; keyT, nodeT &gt;::serialize()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a1a073315c075bdd2592aaaa8c379f2d6">madness::FunctionImpl&lt; Q, NDIM &gt;::unary_op_coeff_inplace()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a77b755e48a4fe27eb61294ffb8c6997a">madness::FunctionImpl&lt; Q, NDIM &gt;::unary_op_node_inplace()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#af298d8e240a8c20c5cc257613dfa9820">madness::FunctionImpl&lt; Q, NDIM &gt;::unary_op_value_inplace()</a>, and <a class="el" href="singletonmadness_1_1FunctionImpl.html#a24fedb0d2623262cf104d90ebf4457df">madness::FunctionImpl&lt; Q, NDIM &gt;::vtransform_doit()</a>.</p>

</div>
</div>
<a class="anchor" id="a897f41222d9658504b88d8904a52083b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1WorldContainer.html#a35cb3fd7bebc9d099d9bbd5604dad7c5">const_iterator</a> <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the <em>local</em> data (no communication) </p>

</div>
</div>
<a class="anchor" id="ad34bc4bbc8c2ba4306a91b5d4a1d05db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears all <em>local</em> data (no communication) </p>
<p>Invalidates all iterators </p>

<p>Referenced by <a class="el" href="singletonmadness_1_1FunctionImpl.html#a7e4a4bab64bd4f986a141eaba0a59164">madness::FunctionImpl&lt; Q, NDIM &gt;::make_Vphi()</a>.</p>

</div>
</div>
<a class="anchor" id="a70c0a1d6e1dddb3bf57c27fa93ed88f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1WorldContainer.html#a9e791b5a3fc38f5ea812aaa95f960358">iterator</a> <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator past the end of the <em>local</em> data (no communication) </p>

<p>Referenced by <a class="el" href="singletonmadness_1_1FunctionImpl.html#a4b704078131f7ecb7c7d3a976c8f58f6">madness::FunctionImpl&lt; Q, NDIM &gt;::apply()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a2f29c97ee3460c508358c745c18ed045">madness::FunctionImpl&lt; Q, NDIM &gt;::apply_1d_realspace_push()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a8db02bd27cae75e5d1a7136bf33048ac">madness::FunctionImpl&lt; Q, NDIM &gt;::apply_source_driven()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a5cfb6018da8347088739b153800f885a">madness::FunctionImpl&lt; Q, NDIM &gt;::binaryXXa()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a01a44d740aafcc1d25e7572c3e01da41">madness::FunctionImpl&lt; Q, NDIM &gt;::copy_coeffs()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#af70e81ec7aed49a6ced5172093afe081">madness::FunctionImpl&lt; T, NDIM &gt;::diff()</a>, <a class="el" href="singletonmadness_1_1WorldContainer.html#a266b89315762fc6da067d393dd6f030e">madness::WorldContainer&lt; keyT, nodeT &gt;::end()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a3072f865bbef4a8796b5b6e286491ad1">madness::FunctionImpl&lt; Q, NDIM &gt;::errsq_local()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a64d1885aa7d559884ec68805f9f1b67b">madness::FunctionImpl&lt; Q, NDIM &gt;::flo_unary_op_node_inplace()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#ac1265473c71e7d40d7c4ead4d2aede45">madness::FunctionImpl&lt; Q, NDIM &gt;::FunctionImpl()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#ac2e447c0d9e9cf645257ba70d27609a7">madness::FunctionImpl&lt; Q, NDIM &gt;::gaxpy()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a8a2692a0d860c4e0bfd34f4a2798c818">madness::FunctionImpl&lt; Q, NDIM &gt;::gaxpy_inplace()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a5689d2b90ff38d77d574c4929ad66276">madness::FunctionImpl&lt; Q, NDIM &gt;::inner_ext_local()</a>, <a class="el" href="classmadness_1_1LoadBalanceDeux.html#a3d9fa5530e39fc761ebeb21c3faab581">madness::LoadBalanceDeux&lt; NDIM &gt;::load_balance()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#aed24dfcc964403cf5ae6b0940d47f90f">madness::FunctionImpl&lt; Q, NDIM &gt;::mulXXa()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a4f5aeee744777eda8edbaae41f5bd97c">madness::FunctionImpl&lt; Q, NDIM &gt;::mulXXveca()</a>, <a class="el" href="classmadness_1_1LoadBalanceDeux.html#a77ef598961e53ee7a61dc1bfdaaa7ae2">madness::LoadBalanceDeux&lt; NDIM &gt;::print_tree()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a5a044779134fabac6a1ae8147d47ce43">madness::FunctionImpl&lt; T, NDIM &gt;::project()</a>, <a class="el" href="singletonmadness_1_1WorldContainer.html#ac66502d2720c995b863b648112ec4961">madness::WorldContainer&lt; keyT, nodeT &gt;::serialize()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a1a073315c075bdd2592aaaa8c379f2d6">madness::FunctionImpl&lt; Q, NDIM &gt;::unary_op_coeff_inplace()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a77b755e48a4fe27eb61294ffb8c6997a">madness::FunctionImpl&lt; Q, NDIM &gt;::unary_op_node_inplace()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#af298d8e240a8c20c5cc257613dfa9820">madness::FunctionImpl&lt; Q, NDIM &gt;::unary_op_value_inplace()</a>, and <a class="el" href="singletonmadness_1_1FunctionImpl.html#a24fedb0d2623262cf104d90ebf4457df">madness::FunctionImpl&lt; Q, NDIM &gt;::vtransform_doit()</a>.</p>

</div>
</div>
<a class="anchor" id="a266b89315762fc6da067d393dd6f030e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1WorldContainer.html#a35cb3fd7bebc9d099d9bbd5604dad7c5">const_iterator</a> <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator past the end of the <em>local</em> data (no communication) </p>

</div>
</div>
<a class="anchor" id="a57c28252d7728e2f147560acc372de02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases entry from container (non-blocking comm if remote) </p>
<p>Missing keys are quietly ignored.</p>
<p>Note that erasing an entry may invalidate iterators on the remote end. This is just the same as what happens when using STL iterators on an STL container in a sequential algorithm. </p>

</div>
</div>
<a class="anchor" id="a807b5392da4f974189c42264f498bb83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="singletonmadness_1_1WorldContainer.html#a9e791b5a3fc38f5ea812aaa95f960358">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases entry corresponding to <em>local</em> iterator (no communication) </p>

</div>
</div>
<a class="anchor" id="a8316a8a6c63a987144f1742d41255e5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="singletonmadness_1_1WorldContainer.html#a9e791b5a3fc38f5ea812aaa95f960358">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="singletonmadness_1_1WorldContainer.html#a9e791b5a3fc38f5ea812aaa95f960358">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>finish</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases range defined by <em>local</em> iterators (no communication) </p>

</div>
</div>
<a class="anchor" id="a0b0471987c01e9d46eccad3698bfad3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singletonmadness_1_1WorldContainer.html#aff1d939195a25f8a55566630b3758aa9">accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write access to LOCAL value by key. Returns true if found, false otherwise (always false for remote). </p>

<p>Referenced by <a class="el" href="singletonmadness_1_1FunctionImpl.html#a5cfb6018da8347088739b153800f885a">madness::FunctionImpl&lt; Q, NDIM &gt;::binaryXXa()</a>, <a class="el" href="singletonmadness_1_1WorldContainer.html#a5a89f2011fbed581016bc316286a48dc">madness::WorldContainer&lt; keyT, nodeT &gt;::find()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a3d7f147ae9c3fdc45f605b5c39dba909">madness::FunctionImpl&lt; Q, NDIM &gt;::inner_ext_recursive()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a44fdee7cbb76ed260b4ee61ae064d239">madness::FunctionImpl&lt; Q, NDIM &gt;::multiop_values_doit()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#aed24dfcc964403cf5ae6b0940d47f90f">madness::FunctionImpl&lt; Q, NDIM &gt;::mulXXa()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a4f5aeee744777eda8edbaae41f5bd97c">madness::FunctionImpl&lt; Q, NDIM &gt;::mulXXveca()</a>, <a class="el" href="structmadness_1_1leaf__op.html#abe43328422587cf9775546e77d9c4d17">madness::leaf_op&lt; T, NDIM &gt;::operator()()</a>, <a class="el" href="structmadness_1_1FunctionImpl_1_1do__check__symmetry__local.html#abd158ffe478dcd391d76b8dc2db8bb6b">madness::FunctionImpl&lt; T, NDIM &gt;::do_check_symmetry_local::operator()()</a>, <a class="el" href="structmadness_1_1FunctionImpl_1_1do__merge__trees.html#a878b991b43c761f2483619922b23fb60">madness::FunctionImpl&lt; T, NDIM &gt;::do_merge_trees&lt; Q, R &gt;::operator()()</a>, <a class="el" href="structmadness_1_1FunctionImpl_1_1do__average.html#a85034b2c71a9e8b60942bb07f38cd89e">madness::FunctionImpl&lt; T, NDIM &gt;::do_average::operator()()</a>, <a class="el" href="structmadness_1_1FunctionImpl_1_1do__inner__local.html#a061ebd0ebd155e1028310468dfcd47dd">madness::FunctionImpl&lt; T, NDIM &gt;::do_inner_local&lt; R &gt;::operator()()</a>, <a class="el" href="structmadness_1_1FunctionImpl_1_1project__out__op.html#a30105ff3a0ba15727e1775fb7e39345f">madness::FunctionImpl&lt; T, NDIM &gt;::project_out_op&lt; LDIM &gt;::operator()()</a>, <a class="el" href="classmadness_1_1LoadBalanceDeux.html#a77ef598961e53ee7a61dc1bfdaaa7ae2">madness::LoadBalanceDeux&lt; NDIM &gt;::print_tree()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a461b9cfeecda475e44fad37ed7094a9f">madness::FunctionImpl&lt; Q, NDIM &gt;::refine_op()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#ac71e99d75108bdf191fa72b1ec4b3f6f">madness::FunctionImpl&lt; Q, NDIM &gt;::refine_spawn()</a>, and <a class="el" href="singletonmadness_1_1FunctionImpl.html#ad1a5e84327485e8a20ac91381637abaf">madness::FunctionImpl&lt; Q, NDIM &gt;::unaryXXa()</a>.</p>

</div>
</div>
<a class="anchor" id="a38700f69dacc4eac22ae82b5da424378"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singletonmadness_1_1WorldContainer.html#ad87d6b2d720e96bb054aae89273e601a">const_accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read access to LOCAL value by key. Returns true if found, false otherwise (always false for remote). </p>

</div>
</div>
<a class="anchor" id="a643f7d88ee8385d88cb21e6911b77f93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt;<a class="el" href="singletonmadness_1_1WorldContainer.html#a9e791b5a3fc38f5ea812aaa95f960358">iterator</a>&gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a future iterator (non-blocking communication if key not local) </p>
<p>Like an std::map an iterator "points" to an std::pair&lt;const keyT,valueT&gt;.</p>
<p>Refer to <a class="el" href="singletonmadness_1_1Future.html" title="A future is a possibly yet unevaluated value. ">Future</a> for info on how to avoid blocking. </p>

</div>
</div>
<a class="anchor" id="a5a89f2011fbed581016bc316286a48dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt;<a class="el" href="singletonmadness_1_1WorldContainer.html#a35cb3fd7bebc9d099d9bbd5604dad7c5">const_iterator</a>&gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a future iterator (non-blocking communication if key not local) </p>
<p>Like an std::map an iterator "points" to an std::pair&lt;const keyT,valueT&gt;.</p>
<p>Refer to <a class="el" href="singletonmadness_1_1Future.html" title="A future is a possibly yet unevaluated value. ">Future</a> for info on how to avoid blocking. </p>

</div>
</div>
<a class="anchor" id="a0fd0ffcec2674a8951c29cd48691850f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hashfunT&amp; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::get_hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the hashing functor. </p>

</div>
</div>
<a class="anchor" id="aefd3bfeea82fe9ee38a8c7bf1916844c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="singletonmadness_1_1tr1_1_1shptr_1_1shared__ptr.html">std::shared_ptr</a>&lt; <a class="el" href="singletonmadness_1_1WorldDCPmapInterface.html">WorldDCPmapInterface</a>&lt;keyT&gt; &gt;&amp; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::get_pmap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns shared pointer to the process mapping. </p>

</div>
</div>
<a class="anchor" id="af761298a39e16a522fa1f15dfd09ed5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmadness_1_1World.html">World</a>&amp; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::get_world </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the world associated with this container. </p>

</div>
</div>
<a class="anchor" id="a61b223ae963f12a7e33421216b8efe2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmadness_1_1uniqueidT.html">uniqueidT</a>&amp; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the associated unique id ... must be initialized. </p>

</div>
</div>
<a class="anchor" id="a7cd86d2f216f8d18d3729d660688ed38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singletonmadness_1_1WorldContainer.html#aff1d939195a25f8a55566630b3758aa9">accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write access to LOCAL value by key. Returns true if inserted, false if already exists (throws if remote) </p>

<p>Referenced by <a class="el" href="singletonmadness_1_1WorldContainer.html#a7c00aed66223ebe9b0f24ba1f766709d">madness::WorldContainer&lt; keyT, nodeT &gt;::replace()</a>, and <a class="el" href="singletonmadness_1_1FunctionImpl.html#a24fedb0d2623262cf104d90ebf4457df">madness::FunctionImpl&lt; Q, NDIM &gt;::vtransform_doit()</a>.</p>

</div>
</div>
<a class="anchor" id="a1735eb753372d4538e251c2affaa279a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singletonmadness_1_1WorldContainer.html#ad87d6b2d720e96bb054aae89273e601a">const_accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read access to LOCAL value by key. Returns true if inserted, false if already exists (throws if remote) </p>

</div>
</div>
<a class="anchor" id="a6a86a26e1a2809f3bc359500b654ca4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::is_local </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the key maps to the local processor (no communication) </p>

<p>Referenced by <a class="el" href="singletonmadness_1_1FunctionImpl.html#a98feba9e053c4d3a8190ed8b769b7c60">madness::FunctionImpl&lt; Q, NDIM &gt;::forward_traverse()</a>, <a class="el" href="structmadness_1_1leaf__op.html#abe43328422587cf9775546e77d9c4d17">madness::leaf_op&lt; T, NDIM &gt;::operator()()</a>, and <a class="el" href="singletonmadness_1_1FunctionImpl.html#a9221bbf6f22a05193cefe7d14bb5b69f">madness::FunctionImpl&lt; Q, NDIM &gt;::traverse_tree()</a>.</p>

</div>
</div>
<a class="anchor" id="acf4e5f58edc5f8eebe28fbf1a1299315"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1WorldContainer.html#a76541de6b3a4625db55abd0fb13b3e4e">containerT</a>&amp; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="singletonmadness_1_1WorldContainer.html#a76541de6b3a4625db55abd0fb13b3e4e">containerT</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment is shallow (no communication) </p>
<p>The copy refers to exactly the same container as other which must be initialized. </p>

</div>
</div>
<a class="anchor" id="ab09b294448286e7aa7e4011ce358e585"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="worldtypes_8h.html#a001bdf5fdc48ff6502265ebdc8c0f148">ProcessID</a> <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::owner </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns processor that logically owns key (no communication) </p>
<p>Local remapping may have changed its physical location, but all operations should forward correctly. </p>

<p>Referenced by <a class="el" href="singletonmadness_1_1FunctionImpl.html#a4b704078131f7ecb7c7d3a976c8f58f6">madness::FunctionImpl&lt; Q, NDIM &gt;::apply()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a8db02bd27cae75e5d1a7136bf33048ac">madness::FunctionImpl&lt; Q, NDIM &gt;::apply_source_driven()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a0a1a4a80993d6596de76685b0d8ac3d6">madness::FunctionImpl&lt; Q, NDIM &gt;::binaryXX()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a5cfb6018da8347088739b153800f885a">madness::FunctionImpl&lt; Q, NDIM &gt;::binaryXXa()</a>, <a class="el" href="structmadness_1_1FunctionImpl_1_1Vphi__op__NS.html#a2d25309c6e023b45b966a8e556d00eb3">madness::FunctionImpl&lt; T, NDIM &gt;::Vphi_op_NS&lt; opT, LDIM &gt;::continue_recursion()</a>, <a class="el" href="classmadness_1_1DerivativeBase.html#af88dff8c8a20dd088e466284de7fe607">madness::DerivativeBase&lt; T, NDIM &gt;::find_neighbor()</a>, <a class="el" href="classmadness_1_1DerivativeBase.html#a9676d58136944b23910b36e965f1f902">madness::DerivativeBase&lt; T, NDIM &gt;::forward_do_diff1()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#ac1265473c71e7d40d7c4ead4d2aede45">madness::FunctionImpl&lt; Q, NDIM &gt;::FunctionImpl()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a50f50a8f826d86bc748a4436c2bbdd5d">madness::FunctionImpl&lt; Q, NDIM &gt;::gaxpy_ext()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a81ec6703f642325bf89f39076f79e724">madness::FunctionImpl&lt; Q, NDIM &gt;::gaxpy_inplace_reconstructed()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#abaad645bfab180ed10aae14de4ba453b">madness::FunctionImpl&lt; Q, NDIM &gt;::hartree_product()</a>, <a class="el" href="classmadness_1_1LoadBalanceDeux.html#a3d9fa5530e39fc761ebeb21c3faab581">madness::LoadBalanceDeux&lt; NDIM &gt;::load_balance()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a7e4a4bab64bd4f986a141eaba0a59164">madness::FunctionImpl&lt; Q, NDIM &gt;::make_Vphi()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a031f3e2ece1ab0357c3eb7e671118ab4">madness::FunctionImpl&lt; Q, NDIM &gt;::multiply()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#aa3989fefeff5c8f75e77e2aaca1c73ce">madness::FunctionImpl&lt; Q, NDIM &gt;::mulXX()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#aed24dfcc964403cf5ae6b0940d47f90f">madness::FunctionImpl&lt; Q, NDIM &gt;::mulXXa()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#ad6e7634b4d89f808999023699a78f005">madness::FunctionImpl&lt; Q, NDIM &gt;::mulXXvec()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a4f5aeee744777eda8edbaae41f5bd97c">madness::FunctionImpl&lt; Q, NDIM &gt;::mulXXveca()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a809e2d76145589f50b90a025dcdde839">madness::FunctionImpl&lt; Q, NDIM &gt;::project_out()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#ac670bf68dfdb4c5260952d25c7e6a3fd">madness::FunctionImpl&lt; Q, NDIM &gt;::project_out2()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#af6dad2fdb6d08f74258cddab997c531f">madness::FunctionImpl&lt; Q, NDIM &gt;::recursive_apply()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#af0c877a808a29d40e88df798434dfc47">madness::FunctionImpl&lt; Q, NDIM &gt;::refine()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#ac71e99d75108bdf191fa72b1ec4b3f6f">madness::FunctionImpl&lt; Q, NDIM &gt;::refine_spawn()</a>, <a class="el" href="singletonmadness_1_1WorldContainer.html#a09200e32d824253061dca50cade7327c">madness::WorldContainer&lt; keyT, nodeT &gt;::send()</a>, <a class="el" href="singletonmadness_1_1WorldContainer.html#aeb91e7b56f91ef4b947920798f631c5d">madness::WorldContainer&lt; keyT, nodeT &gt;::task()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a9221bbf6f22a05193cefe7d14bb5b69f">madness::FunctionImpl&lt; Q, NDIM &gt;::traverse_tree()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a7fac0d32385304aaecdcd993a146a83b">madness::FunctionImpl&lt; Q, NDIM &gt;::unaryXX()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#ad1a5e84327485e8a20ac91381637abaf">madness::FunctionImpl&lt; Q, NDIM &gt;::unaryXXa()</a>, and <a class="el" href="singletonmadness_1_1FunctionImpl.html#a4394a2b0cf6144de892978d991f27808">madness::FunctionImpl&lt; Q, NDIM &gt;::unaryXXvalues()</a>.</p>

</div>
</div>
<a class="anchor" id="a0c7dcc9d0d33a281dee3c1e963c90865"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::probe </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if local data is immediately available (no communication) </p>

<p>Referenced by <a class="el" href="structmadness_1_1FunctionImpl_1_1do__check__symmetry__local.html#abd158ffe478dcd391d76b8dc2db8bb6b">madness::FunctionImpl&lt; T, NDIM &gt;::do_check_symmetry_local::operator()()</a>, <a class="el" href="structmadness_1_1FunctionImpl_1_1do__inner__local.html#a061ebd0ebd155e1028310468dfcd47dd">madness::FunctionImpl&lt; T, NDIM &gt;::do_inner_local&lt; R &gt;::operator()()</a>, and <a class="el" href="structmadness_1_1FunctionImpl_1_1project__out__op.html#a30105ff3a0ba15727e1775fb7e39345f">madness::FunctionImpl&lt; T, NDIM &gt;::project_out_op&lt; LDIM &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a03d4e7b5aee2f829ac6405504a209cee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::process_pending </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process pending messages. </p>
<p>If the constructor was given <code>do_pending=false</code> then you <em>must</em> invoke this routine in order to process both prior and future messages. </p>

<p>Referenced by <a class="el" href="singletonmadness_1_1FunctionImpl.html#ac1265473c71e7d40d7c4ead4d2aede45">madness::FunctionImpl&lt; Q, NDIM &gt;::FunctionImpl()</a>.</p>

</div>
</div>
<a class="anchor" id="a6e2fe70f494016ced802385bab5adda2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="singletonmadness_1_1WorldContainer.html#aa5de3ee1a42b959d182a4d68649f21ae">pairT</a> &amp;&#160;</td>
          <td class="paramname"><em>datum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts/replaces key+value pair (non-blocking communication if key not local) </p>

<p>Referenced by <a class="el" href="singletonmadness_1_1FunctionImpl.html#a5cfb6018da8347088739b153800f885a">madness::FunctionImpl&lt; Q, NDIM &gt;::binaryXXa()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a01a44d740aafcc1d25e7572c3e01da41">madness::FunctionImpl&lt; Q, NDIM &gt;::copy_coeffs()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a28c6623a7488557200dccefddf5f056e">madness::FunctionImpl&lt; Q, NDIM &gt;::do_binary_op()</a>, <a class="el" href="classmadness_1_1DerivativeBase.html#a90f219883fd7fc409ace5f9405ce94ac">madness::DerivativeBase&lt; T, NDIM &gt;::do_diff1()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a2ec6ef2be180c2d529649ed5c6ee339c">madness::FunctionImpl&lt; Q, NDIM &gt;::do_mul()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a78ab66e52f6fe86e76f1d00d568bf927">madness::FunctionImpl&lt; Q, NDIM &gt;::gaxpy_ext_recursive()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a7e4a4bab64bd4f986a141eaba0a59164">madness::FunctionImpl&lt; Q, NDIM &gt;::make_Vphi()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#afb483cb2c5ffb357be03a4bf1e2d1437">madness::FunctionImpl&lt; Q, NDIM &gt;::multiop_values()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a44fdee7cbb76ed260b4ee61ae064d239">madness::FunctionImpl&lt; Q, NDIM &gt;::multiop_values_doit()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#aed24dfcc964403cf5ae6b0940d47f90f">madness::FunctionImpl&lt; Q, NDIM &gt;::mulXXa()</a>, <a class="el" href="structmadness_1_1insert__op.html#a440efaccd130a394a818e0947a068a20">madness::insert_op&lt; T, NDIM &gt;::operator()()</a>, <a class="el" href="structmadness_1_1FunctionImpl_1_1do__merge__trees.html#a878b991b43c761f2483619922b23fb60">madness::FunctionImpl&lt; T, NDIM &gt;::do_merge_trees&lt; Q, R &gt;::operator()()</a>, <a class="el" href="structmadness_1_1FunctionImpl_1_1do__mapdim.html#a23eaa579505313511416f2b465a77606">madness::FunctionImpl&lt; T, NDIM &gt;::do_mapdim::operator()()</a>, <a class="el" href="structmadness_1_1FunctionImpl_1_1do__average.html#a85034b2c71a9e8b60942bb07f38cd89e">madness::FunctionImpl&lt; T, NDIM &gt;::do_average::operator()()</a>, <a class="el" href="structmadness_1_1FunctionImpl_1_1Vphi__op__NS.html#aef1e85a604a71a9ec41409b0330c845d">madness::FunctionImpl&lt; T, NDIM &gt;::Vphi_op_NS&lt; opT, LDIM &gt;::operator()()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a23dab70a10e1e72723b44c2377adc1b0">madness::FunctionImpl&lt; Q, NDIM &gt;::read_grid()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a2e41da21cbc185f769dc2cc855de5637">madness::FunctionImpl&lt; Q, NDIM &gt;::read_grid2()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a461b9cfeecda475e44fad37ed7094a9f">madness::FunctionImpl&lt; Q, NDIM &gt;::refine_op()</a>, <a class="el" href="singletonmadness_1_1WorldContainer.html#a16c0a8c68cfa837299bea290a9c2cef6">madness::WorldContainer&lt; keyT, nodeT &gt;::replace()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#ae9105c59663ed539ac001a7dcbe4ac71">madness::FunctionImpl&lt; Q, NDIM &gt;::scale_oop()</a>, <a class="el" href="singletonmadness_1_1WorldContainer.html#ac66502d2720c995b863b648112ec4961">madness::WorldContainer&lt; keyT, nodeT &gt;::serialize()</a>, and <a class="el" href="singletonmadness_1_1FunctionImpl.html#ad1a5e84327485e8a20ac91381637abaf">madness::FunctionImpl&lt; Q, NDIM &gt;::unaryXXa()</a>.</p>

</div>
</div>
<a class="anchor" id="a16c0a8c68cfa837299bea290a9c2cef6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const valueT &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts/replaces key+value pair (non-blocking communication if key not local) </p>

</div>
</div>
<a class="anchor" id="a7c00aed66223ebe9b0f24ba1f766709d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename input_iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">input_iterator &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts pairs (non-blocking communication if key(s) not local) </p>

</div>
</div>
<a class="anchor" id="a09200e32d824253061dca50cade7327c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends message "resultT memfun()" to item (non-blocking comm if remote) </p>
<p>If item does not exist it is made with the default constructor.</p>
<p><a class="el" href="singletonmadness_1_1Future.html" title="A future is a possibly yet unevaluated value. ">Future</a> arguments must be ready for remote messages.</p>
<p>Returns a future result (<a class="el" href="classmadness_1_1Future_3_01void_01_4.html" title="Specialization of Future<void> for internal convenience ... does nothing useful! ">Future&lt;void&gt;</a> may be ignored).</p>
<p>The method executes with a write lock on the item. </p>

<p>Referenced by <a class="el" href="singletonmadness_1_1FunctionImpl.html#ac2e447c0d9e9cf645257ba70d27609a7">madness::FunctionImpl&lt; Q, NDIM &gt;::gaxpy()</a>, <a class="el" href="classmadness_1_1LoadBalanceDeux.html#a3d9fa5530e39fc761ebeb21c3faab581">madness::LoadBalanceDeux&lt; NDIM &gt;::load_balance()</a>, and <a class="el" href="singletonmadness_1_1WorldContainer.html#a4c915bb6305bdc4b61d651206cdaaaf5">madness::WorldContainer&lt; keyT, nodeT &gt;::send()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e32c17bd9d4c52ad5e618f09e9f6e7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const memfunT &amp;&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends message "resultT memfun(arg1T)" to item (non-blocking comm if remote) </p>
<p>If item does not exist it is made with the default constructor.</p>
<p><a class="el" href="singletonmadness_1_1Future.html" title="A future is a possibly yet unevaluated value. ">Future</a> arguments must be ready for remote messages.</p>
<p>Returns a future result (<a class="el" href="classmadness_1_1Future_3_01void_01_4.html" title="Specialization of Future<void> for internal convenience ... does nothing useful! ">Future&lt;void&gt;</a> may be ignored).</p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="aba80a61b03f59f70dfdd6ec3f8e76df1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends message "resultT memfun(arg1T,arg2T)" to item (non-blocking comm if remote) </p>
<p>If item does not exist it is made with the default constructor.</p>
<p><a class="el" href="singletonmadness_1_1Future.html" title="A future is a possibly yet unevaluated value. ">Future</a> arguments must be ready for both local and remote messages.</p>
<p>Returns a future result (<a class="el" href="classmadness_1_1Future_3_01void_01_4.html" title="Specialization of Future<void> for internal convenience ... does nothing useful! ">Future&lt;void&gt;</a> may be ignored).</p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="a46cb28c1908ab480e3144aaaf7f91a19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg3T &amp;&#160;</td>
          <td class="paramname"><em>arg3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends message "resultT memfun(arg1T,arg2T,arg3T)" to item (non-blocking comm if remote) </p>
<p>If item does not exist it is made with the default constructor.</p>
<p><a class="el" href="singletonmadness_1_1Future.html" title="A future is a possibly yet unevaluated value. ">Future</a> arguments must be ready for both local and remote messages.</p>
<p>Returns a future result (<a class="el" href="classmadness_1_1Future_3_01void_01_4.html" title="Specialization of Future<void> for internal convenience ... does nothing useful! ">Future&lt;void&gt;</a> may be ignored).</p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="a40bdd5728e78c986f7c36447c7ab2eed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg3T &amp;&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg4T &amp;&#160;</td>
          <td class="paramname"><em>arg4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends message "resultT memfun(arg1T,arg2T,arg3T,arg4T)" to item (non-blocking comm if remote) </p>
<p>If item does not exist it is made with the default constructor.</p>
<p><a class="el" href="singletonmadness_1_1Future.html" title="A future is a possibly yet unevaluated value. ">Future</a> arguments must be ready for both local and remote messages.</p>
<p>Returns a future result (<a class="el" href="classmadness_1_1Future_3_01void_01_4.html" title="Specialization of Future<void> for internal convenience ... does nothing useful! ">Future&lt;void&gt;</a> may be ignored).</p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="aaaba470ffd9246ed91b17184c98f27de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg3T &amp;&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg4T &amp;&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg5T &amp;&#160;</td>
          <td class="paramname"><em>arg5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends message "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T)" to item (non-blocking comm if remote) </p>
<p>If item does not exist it is made with the default constructor.</p>
<p><a class="el" href="singletonmadness_1_1Future.html" title="A future is a possibly yet unevaluated value. ">Future</a> arguments must be ready for both local and remote messages.</p>
<p>Returns a future result (<a class="el" href="classmadness_1_1Future_3_01void_01_4.html" title="Specialization of Future<void> for internal convenience ... does nothing useful! ">Future&lt;void&gt;</a> may be ignored).</p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="a8fe7bba801fe7c24d02428fda359fbe4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T , typename arg6T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg3T &amp;&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg4T &amp;&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg5T &amp;&#160;</td>
          <td class="paramname"><em>arg5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg6T &amp;&#160;</td>
          <td class="paramname"><em>arg6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends message "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T,arg6T)" to item (non-blocking comm if remote) </p>
<p>If item does not exist it is made with the default constructor.</p>
<p><a class="el" href="singletonmadness_1_1Future.html" title="A future is a possibly yet unevaluated value. ">Future</a> arguments must be ready for both local and remote messages.</p>
<p>Returns a future result (<a class="el" href="classmadness_1_1Future_3_01void_01_4.html" title="Specialization of Future<void> for internal convenience ... does nothing useful! ">Future&lt;void&gt;</a> may be ignored).</p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="a786052953d0cb91fc50cc5f11ea6bdb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T , typename arg6T , typename arg7T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg3T &amp;&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg4T &amp;&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg5T &amp;&#160;</td>
          <td class="paramname"><em>arg5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg6T &amp;&#160;</td>
          <td class="paramname"><em>arg6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg7T &amp;&#160;</td>
          <td class="paramname"><em>arg7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends message "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T,arg6T,arg7T)" to item (non-blocking comm if remote) </p>
<p>If item does not exist it is made with the default constructor.</p>
<p><a class="el" href="singletonmadness_1_1Future.html" title="A future is a possibly yet unevaluated value. ">Future</a> arguments must be ready for both local and remote messages.</p>
<p>Returns a future result (<a class="el" href="classmadness_1_1Future_3_01void_01_4.html" title="Specialization of Future<void> for internal convenience ... does nothing useful! ">Future&lt;void&gt;</a> may be ignored).</p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="a4c915bb6305bdc4b61d651206cdaaaf5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends message "resultT memfun() const" to item (non-blocking comm if remote) </p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="a67ad81529eb73e5cc4d4d1b944a3f7d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends message "resultT memfun(arg1T) const" to item (non-blocking comm if remote) </p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="a8fa121fd6180fbaed2535dbb8f807a1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends message "resultT memfun(arg1T,arg2T) const" to item (non-blocking comm if remote) </p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="a48fbc751e41265c4809c9bd31746569f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg3T &amp;&#160;</td>
          <td class="paramname"><em>arg3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends message "resultT memfun(arg1T,arg2T,arg3T) const" to item (non-blocking comm if remote) </p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="a8d76c0317a4f3893781dc22ea6ebbbf8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg3T &amp;&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg4T &amp;&#160;</td>
          <td class="paramname"><em>arg4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends message "resultT memfun(arg1T,arg2T,arg3T,arg4T) const" to item (non-blocking comm if remote) </p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="afda2742ee88d3d3b5b2f1d16ee2b4de3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg3T &amp;&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg4T &amp;&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg5T &amp;&#160;</td>
          <td class="paramname"><em>arg5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends message "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T) const" to item (non-blocking comm if remote) </p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="a9a0009eebb76552cd71c7e303b302115"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T , typename arg6T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg3T &amp;&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg4T &amp;&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg5T &amp;&#160;</td>
          <td class="paramname"><em>arg5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg6T &amp;&#160;</td>
          <td class="paramname"><em>arg6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends message "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T,arg6T) const" to item (non-blocking comm if remote) </p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="afc6af7eff7dffcb93fb096cbcb0fc7bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T , typename arg6T , typename arg7T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg3T &amp;&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg4T &amp;&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg5T &amp;&#160;</td>
          <td class="paramname"><em>arg5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg6T &amp;&#160;</td>
          <td class="paramname"><em>arg6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg7T &amp;&#160;</td>
          <td class="paramname"><em>arg7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends message "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T,arg6T,arg7T) const" to item (non-blocking comm if remote) </p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="ac66502d2720c995b863b648112ec4961"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">const Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(de)Serialize &mdash; <em>Local</em> data only to/from anything <em>except</em> Buffer*Archive and Parallel*Archive </p>
<p>Advisable for <em>you</em> to fence before and after this to ensure consistency </p>

</div>
</div>
<a class="anchor" id="a477c146f9a1c88a29ea1c67fa4d2dfd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmadness_1_1archive_1_1BufferOutputArchive.html">archive::BufferOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(de)Serialize &mdash; !! ONLY for purpose of interprocess communication </p>
<p>This just writes/reads the unique id to/from the Buffer*Archive. </p>

</div>
</div>
<a class="anchor" id="ab6b352828b108832d63c324dd36f6399"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmadness_1_1archive_1_1BufferInputArchive.html">archive::BufferInputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(de)Serialize &mdash; !! ONLY for purpose of interprocess communication </p>
<p>This just writes/reads the unique id to/from the Buffer*Archive. </p>

</div>
</div>
<a class="anchor" id="af415676e3d9721768a6f457144091557"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of <em>local</em> entries (no communication) </p>

</div>
</div>
<a class="anchor" id="aeb91e7b56f91ef4b947920798f631c5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::task </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds task "resultT memfun()" in process owning item (non-blocking comm if remote) </p>
<p>If item does not exist it is made with the default constructor.</p>
<p><a class="el" href="singletonmadness_1_1Future.html" title="A future is a possibly yet unevaluated value. ">Future</a> arguments for local tasks can generate dependencies, but for remote tasks all futures must be ready.</p>
<p>Returns a future result (<a class="el" href="classmadness_1_1Future_3_01void_01_4.html" title="Specialization of Future<void> for internal convenience ... does nothing useful! ">Future&lt;void&gt;</a> may be ignored).</p>
<p>The method executes with a write lock on the item. </p>

<p>Referenced by <a class="el" href="singletonmadness_1_1FunctionImpl.html#a2aeed89dbbd2294662dbcbd834cc7381">madness::FunctionImpl&lt; Q, NDIM &gt;::apply_1d_realspace_push_op()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a0197e7c810a2f9077a5d6edc42ea4e96">madness::FunctionImpl&lt; Q, NDIM &gt;::do_apply()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a923326efb38513fb38c65a71f7987de5">madness::FunctionImpl&lt; Q, NDIM &gt;::do_apply_kernel()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#ac717c99e708888fc0241891d82986a37">madness::FunctionImpl&lt; Q, NDIM &gt;::do_apply_kernel2()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a0fbaf7560078814141a90d23edf5c908">madness::FunctionImpl&lt; Q, NDIM &gt;::do_apply_kernel3()</a>, <a class="el" href="singletonmadness_1_1FunctionImpl.html#a18aaf1367c821d7721e15008dfe53e22">madness::FunctionImpl&lt; Q, NDIM &gt;::do_project_out()</a>, <a class="el" href="structmadness_1_1FunctionImpl_1_1project__out__op.html#a30105ff3a0ba15727e1775fb7e39345f">madness::FunctionImpl&lt; T, NDIM &gt;::project_out_op&lt; LDIM &gt;::operator()()</a>, <a class="el" href="singletonmadness_1_1WorldContainer.html#a355ffe9952fc500ffd464487cbdc6fa8">madness::WorldContainer&lt; keyT, nodeT &gt;::task()</a>, and <a class="el" href="singletonmadness_1_1FunctionImpl.html#a24fedb0d2623262cf104d90ebf4457df">madness::FunctionImpl&lt; Q, NDIM &gt;::vtransform_doit()</a>.</p>

</div>
</div>
<a class="anchor" id="a2482ce6ef6840af22f1c792c38316b7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::task </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds task "resultT memfun(arg1T)" in process owning item (non-blocking comm if remote) </p>
<p>If item does not exist it is made with the default constructor.</p>
<p><a class="el" href="singletonmadness_1_1Future.html" title="A future is a possibly yet unevaluated value. ">Future</a> arguments for local tasks can generate dependencies, but for remote tasks all futures must be ready.</p>
<p>Returns a future result (<a class="el" href="classmadness_1_1Future_3_01void_01_4.html" title="Specialization of Future<void> for internal convenience ... does nothing useful! ">Future&lt;void&gt;</a> may be ignored).</p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="ab214b3e638b425143068a4125bef43f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::task </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds task "resultT memfun(arg1T,arg2T)" in process owning item (non-blocking comm if remote) </p>
<p>If item does not exist it is made with the default constructor.</p>
<p><a class="el" href="singletonmadness_1_1Future.html" title="A future is a possibly yet unevaluated value. ">Future</a> arguments for local tasks can generate dependencies, but for remote tasks all futures must be ready.</p>
<p>Returns a future result (<a class="el" href="classmadness_1_1Future_3_01void_01_4.html" title="Specialization of Future<void> for internal convenience ... does nothing useful! ">Future&lt;void&gt;</a> may be ignored).</p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="a4a5b539b6e95db76fe5c2091b3521976"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::task </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg3T &amp;&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds task "resultT memfun(arg1T,arg2T,arg3T)" in process owning item (non-blocking comm if remote) </p>
<p>If item does not exist it is made with the default constructor.</p>
<p><a class="el" href="singletonmadness_1_1Future.html" title="A future is a possibly yet unevaluated value. ">Future</a> arguments for local tasks can generate dependencies, but for remote tasks all futures must be ready.</p>
<p>Returns a future result (<a class="el" href="classmadness_1_1Future_3_01void_01_4.html" title="Specialization of Future<void> for internal convenience ... does nothing useful! ">Future&lt;void&gt;</a> may be ignored).</p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="a168e99cadc8fd92c983dd9168858f7c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::task </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg3T &amp;&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg4T &amp;&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds task "resultT memfun(arg1T,arg2T,arg3T,arg4T)" in process owning item (non-blocking comm if remote) </p>
<p>If item does not exist it is made with the default constructor.</p>
<p><a class="el" href="singletonmadness_1_1Future.html" title="A future is a possibly yet unevaluated value. ">Future</a> arguments for local tasks can generate dependencies, but for remote tasks all futures must be ready.</p>
<p>Returns a future result (<a class="el" href="classmadness_1_1Future_3_01void_01_4.html" title="Specialization of Future<void> for internal convenience ... does nothing useful! ">Future&lt;void&gt;</a> may be ignored).</p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="a97fd2ea28895258f3575924bf1446591"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::task </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg3T &amp;&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg4T &amp;&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg5T &amp;&#160;</td>
          <td class="paramname"><em>arg5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds task "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T)" in process owning item (non-blocking comm if remote) </p>
<p>If item does not exist it is made with the default constructor.</p>
<p><a class="el" href="singletonmadness_1_1Future.html" title="A future is a possibly yet unevaluated value. ">Future</a> arguments for local tasks can generate dependencies, but for remote tasks all futures must be ready.</p>
<p>Returns a future result (<a class="el" href="classmadness_1_1Future_3_01void_01_4.html" title="Specialization of Future<void> for internal convenience ... does nothing useful! ">Future&lt;void&gt;</a> may be ignored).</p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="a3f4a0ffdd2b8ef8b61e0f5181a468ad7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T , typename arg6T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::task </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg3T &amp;&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg4T &amp;&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg5T &amp;&#160;</td>
          <td class="paramname"><em>arg5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg6T &amp;&#160;</td>
          <td class="paramname"><em>arg6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds task "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T,arg6T)" in process owning item (non-blocking comm if remote) </p>
<p>If item does not exist it is made with the default constructor.</p>
<p><a class="el" href="singletonmadness_1_1Future.html" title="A future is a possibly yet unevaluated value. ">Future</a> arguments for local tasks can generate dependencies, but for remote tasks all futures must be ready.</p>
<p>Returns a future result (<a class="el" href="classmadness_1_1Future_3_01void_01_4.html" title="Specialization of Future<void> for internal convenience ... does nothing useful! ">Future&lt;void&gt;</a> may be ignored).</p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="a171ccd4f6b80de77d7c60d46513cd90e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T , typename arg6T , typename arg7T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::task </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg3T &amp;&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg4T &amp;&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg5T &amp;&#160;</td>
          <td class="paramname"><em>arg5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg6T &amp;&#160;</td>
          <td class="paramname"><em>arg6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg7T &amp;&#160;</td>
          <td class="paramname"><em>arg7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds task "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T,arg6T,arg7T)" in process owning item (non-blocking comm if remote) </p>
<p>If item does not exist it is made with the default constructor.</p>
<p><a class="el" href="singletonmadness_1_1Future.html" title="A future is a possibly yet unevaluated value. ">Future</a> arguments for local tasks can generate dependencies, but for remote tasks all futures must be ready.</p>
<p>Returns a future result (<a class="el" href="classmadness_1_1Future_3_01void_01_4.html" title="Specialization of Future<void> for internal convenience ... does nothing useful! ">Future&lt;void&gt;</a> may be ignored).</p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="a355ffe9952fc500ffd464487cbdc6fa8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::task </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds task "resultT memfun() const" in process owning item (non-blocking comm if remote) </p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="aee2143315c812a31198fb3d8180b415d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::task </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds task "resultT memfun(arg1T) const" in process owning item (non-blocking comm if remote) </p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="ad645f59f26afc0a1a1476661e185516d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::task </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds task "resultT memfun(arg1T,arg2T) const" in process owning item (non-blocking comm if remote) </p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="ae369e8c5dc2ba579f533dde2ae2287d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::task </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg3T &amp;&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds task "resultT memfun(arg1T,arg2T,arg3T) const" in process owning item (non-blocking comm if remote) </p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="a926036a5faab5ed433acdc2fd5019447"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::task </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg3T &amp;&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg4T &amp;&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds task "resultT memfun(arg1T,arg2T,arg3T, arg4T) const" in process owning item (non-blocking comm if remote) </p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="a5395aa2c0b0b9c928a3caa2cfe259a63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::task </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg3T &amp;&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg4T &amp;&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg5T &amp;&#160;</td>
          <td class="paramname"><em>arg5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds task "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T) const" in process owning item (non-blocking comm if remote) </p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="abf6adabf939a6a545f3cb8de0c447e4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T , typename arg6T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::task </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg3T &amp;&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg4T &amp;&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg5T &amp;&#160;</td>
          <td class="paramname"><em>arg5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg6T &amp;&#160;</td>
          <td class="paramname"><em>arg6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds task "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T,arg6T) const" in process owning item (non-blocking comm if remote) </p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<a class="anchor" id="aae2f3d287de6a8880bd4ba740b9c7f2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename memfunT , typename arg1T , typename arg2T , typename arg3T , typename arg4T , typename arg5T , typename arg6T , typename arg7T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="singletonmadness_1_1Future.html">Future</a>&lt; <a class="el" href="group__futures.html#ga3f127ba5b2bd0aa7b3387fe1f77e7652">REMFUTURE</a>(<a class="el" href="typestuff_8h.html#ab52f46e7d5b7dd008ca558885532c06e">MEMFUN_RETURNT</a>(memfunT)) &gt; <a class="el" href="singletonmadness_1_1WorldContainer.html">madness::WorldContainer</a>&lt; keyT, valueT, hashfunT &gt;::task </td>
          <td>(</td>
          <td class="paramtype">const keyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memfunT&#160;</td>
          <td class="paramname"><em>memfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg1T &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg2T &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg3T &amp;&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg4T &amp;&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg5T &amp;&#160;</td>
          <td class="paramname"><em>arg5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg6T &amp;&#160;</td>
          <td class="paramname"><em>arg6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg7T &amp;&#160;</td>
          <td class="paramname"><em>arg7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="classmadness_1_1TaskAttributes.html">TaskAttributes</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds task "resultT memfun(arg1T,arg2T,arg3T,arg4T,arg5T,arg6T,arg7T) const" in process owning item (non-blocking comm if remote) </p>
<p>The method executes with a write lock on the item. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a99eb11c47cfe8676bdd2073089ad8673"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT, typename valueT, typename hashfunT  = Hash&lt;keyT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singletonmadness_1_1WorldContainer.html">WorldContainer</a>&lt; keyT, valueT, hashfunT &gt; &amp;&#160;</td>
          <td class="paramname"><em>dc0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="singletonmadness_1_1WorldContainer.html">WorldContainer</a>&lt; keyT, valueT, hashfunT &gt; &amp;&#160;</td>
          <td class="paramname"><em>dc1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the content of two <a class="el" href="singletonmadness_1_1WorldContainer.html" title="Makes a distributed container with specified attributes. ">WorldContainer</a> objects. It should be called on all nodes. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="worlddc_8h_source.html">worlddc.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 26 2014 10:39:48 for MADNESS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
